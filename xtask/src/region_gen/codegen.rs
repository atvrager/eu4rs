//! Rust code generation for regions.rs.

use super::types::{RegionGroup, ResolvedRegion};

/// Generate the complete regions.rs file from resolved regions.
pub fn generate_regions_file(regions: &[ResolvedRegion]) -> String {
    let mut output = String::new();

    // Header
    output.push_str(&generate_header());

    // Region struct definition
    output.push_str(&generate_region_struct());

    // Region constants
    output.push_str(&generate_region_constants(regions));

    // Const arrays
    output.push_str(&generate_const_arrays(regions));

    // Helper function
    output.push_str(&generate_print_legend());

    output
}

fn generate_header() -> String {
    "//! UI region definitions for EU4 screen extraction.
//!
//! These coordinates are calibrated for 1920x1080 vanilla EU4.
//! Use `calibrate.html` to adjust visually.
//!
//! Auto-generated by `cargo xtask generate-regions`.
//! DO NOT EDIT MANUALLY - changes will be overwritten.

"
    .to_string()
}

fn generate_region_struct() -> String {
    r#"/// A rectangular region on the screen for OCR extraction.
#[derive(Debug, Clone, Copy)]
pub struct Region {
    /// Human-readable name for this region
    pub name: &'static str,
    /// X coordinate (pixels from left edge)
    pub x: u32,
    /// Y coordinate (pixels from top edge)
    pub y: u32,
    /// Width in pixels
    pub width: u32,
    /// Height in pixels
    pub height: u32,
    /// RGB color for calibration overlay
    pub color: [u8; 3],
}

impl Region {
    /// Create a new region.
    pub const fn new(
        name: &'static str,
        x: u32,
        y: u32,
        width: u32,
        height: u32,
        color: [u8; 3],
    ) -> Self {
        Self {
            name,
            x,
            y,
            width,
            height,
            color,
        }
    }
}

"#
    .to_string()
}

fn generate_region_constants(regions: &[ResolvedRegion]) -> String {
    let mut output = String::new();

    // Generate top bar regions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Calibrated UI Regions (1920x1080)\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    let top_bar_regions: Vec<_> = regions
        .iter()
        .filter(|r| r.group == RegionGroup::TopBar)
        .collect();

    if !top_bar_regions.is_empty() {
        output.push_str("// Top bar regions\n");
        for region in top_bar_regions {
            output.push_str(&format!(
                "pub const {}: Region = Region::new(\"{}\", {}, {}, {}, {}, {:?});\n",
                region.const_name,
                region.display_name,
                region.x,
                region.y,
                region.width,
                region.height,
                region.color
            ));
        }
        output.push('\n');
    }

    // Generate province panel regions
    let province_panel_regions: Vec<_> = regions
        .iter()
        .filter(|r| r.group == RegionGroup::ProvincePanel)
        .collect();

    if !province_panel_regions.is_empty() {
        output.push_str(
            "// ============================================================================\n",
        );
        output.push_str("// Province Panel Regions (when province selected)\n");
        output.push_str(
            "// ============================================================================\n\n",
        );

        for region in province_panel_regions {
            output.push_str(&format!(
                "pub const {}: Region = Region::new(\"{}\", {}, {}, {}, {}, {:?});\n",
                region.const_name,
                region.display_name,
                region.x,
                region.y,
                region.width,
                region.height,
                region.color
            ));
        }
        output.push('\n');
    }

    output
}

fn generate_const_arrays(regions: &[ResolvedRegion]) -> String {
    let mut output = String::new();

    let top_bar_regions: Vec<_> = regions
        .iter()
        .filter(|r| r.group == RegionGroup::TopBar)
        .collect();

    let province_panel_regions: Vec<_> = regions
        .iter()
        .filter(|r| r.group == RegionGroup::ProvincePanel)
        .collect();

    // Top bar array
    output.push_str("/// Top bar regions (always visible).\n");
    output.push_str("#[allow(dead_code)]\n");
    output.push_str("pub const TOP_BAR_REGIONS: &[Region] = &[\n");
    for region in &top_bar_regions {
        output.push_str(&format!("    {},\n", region.const_name));
    }
    output.push_str("];\n\n");

    // Province panel array
    output.push_str("/// Province panel regions (when province selected).\n");
    output.push_str("#[allow(dead_code)]\n");
    output.push_str("pub const PROVINCE_PANEL_REGIONS: &[Region] = &[\n");
    for region in &province_panel_regions {
        output.push_str(&format!("    {},\n", region.const_name));
    }
    output.push_str("];\n\n");

    // All regions array
    output.push_str("/// All defined regions for iteration.\n");
    output.push_str("pub const ALL_REGIONS: &[Region] = &[\n");
    output.push_str("    // Top bar\n");
    for region in &top_bar_regions {
        output.push_str(&format!("    {},\n", region.const_name));
    }
    output.push_str("    // Province panel\n");
    for region in &province_panel_regions {
        output.push_str(&format!("    {},\n", region.const_name));
    }
    output.push_str("];\n\n");

    output
}

fn generate_print_legend() -> String {
    r#"/// Print a legend of all regions to the console.
pub fn print_legend() {
    println!("Region Legend (1920x1080):");
    println!("{:-<70}", "");
    for region in ALL_REGIONS {
        println!(
            "  {:16} x={:>4}, y={:>3}, w={:>3}, h={:>2}",
            region.name, region.x, region.y, region.width, region.height
        );
    }
    println!("{:-<70}", "");
}
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::region_gen::types::ResolvedRegion;

    #[test]
    fn test_generates_valid_rust() {
        let regions = vec![
            ResolvedRegion {
                const_name: "TREASURY".to_string(),
                display_name: "Treasury".to_string(),
                x: 169,
                y: 13,
                width: 48,
                height: 21,
                color: [0, 255, 0],
                group: RegionGroup::TopBar,
                matched_element: None,
            },
            ResolvedRegion {
                const_name: "PROV_TAX".to_string(),
                display_name: "Prov Tax".to_string(),
                x: 83,
                y: 552,
                width: 25,
                height: 18,
                color: [255, 100, 100],
                group: RegionGroup::ProvincePanel,
                matched_element: None,
            },
        ];

        let code = generate_regions_file(&regions);

        // Basic checks
        assert!(code.contains("pub const TREASURY"));
        assert!(code.contains("pub const PROV_TAX"));
        assert!(code.contains("pub const ALL_REGIONS"));
        assert!(code.contains("pub fn print_legend()"));
    }
}
