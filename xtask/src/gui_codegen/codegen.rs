//! Code generation for GUI panel rendering methods.
//!
//! Generates Rust code for `impl GuiRenderer` blocks with panel-specific rendering methods.

use super::parser;
use super::types::{PanelInfo, WidgetInfo, WidgetType};
use anyhow::{Context, Result};
use eu4game::gui::types::GuiElement;
use std::collections::HashMap;
use std::fmt::Write as FmtWrite;

/// Generate rendering code for a specific panel.
pub fn generate_panel(panel_name: &str, gui_trees: &HashMap<String, GuiElement>) -> Result<String> {
    // Find the window in the GUI trees
    let tree = gui_trees
        .get(panel_name)
        .with_context(|| format!("Panel '{}' not found in GUI trees", panel_name))?;

    let mut output = String::new();

    // Generate header
    writeln!(
        &mut output,
        "// AUTO-GENERATED by cargo xtask generate-gui-renderer"
    )?;
    writeln!(
        &mut output,
        "// Source: {} from parsed GUI files",
        panel_name
    )?;
    writeln!(&mut output, "// DO NOT EDIT - changes will be overwritten")?;
    writeln!(&mut output)?;

    // Generate imports
    writeln!(&mut output, "use crate::gui::GuiRenderer;")?;
    writeln!(
        &mut output,
        "use crate::gui::layout::{{get_window_anchor, position_from_anchor, resolve_position}};"
    )?;
    writeln!(&mut output, "use crate::gui::sprite_cache::SpriteCache;")?;
    writeln!(
        &mut output,
        "use crate::gui::types::{{GfxDatabase, HitBox, Orientation}};"
    )?;
    writeln!(&mut output, "use crate::gui::widget_cache::WidgetCache;")?;
    writeln!(&mut output, "use crate::gui::{{HitBoxCmd, SpriteDrawCmd}};")?;
    writeln!(&mut output, "use crate::render::SpriteRenderer;")?;
    writeln!(&mut output)?;

    // Import panel types
    writeln!(
        &mut output,
        "#[allow(unused_imports)] // Not all types used by every panel"
    )?;
    writeln!(&mut output, "use crate::gui::{{")?;
    writeln!(
        &mut output,
        "    CountrySelectLeftPanel, CountrySelectTopPanel, CountrySelectRightPanel,"
    )?;
    writeln!(&mut output, "    LobbyControlsPanel,")?;
    writeln!(&mut output, "}};")?;
    writeln!(&mut output, "#[allow(unused_imports)]")?;
    writeln!(&mut output, "use crate::gui::main_menu::MainMenuPanel;")?;
    writeln!(&mut output, "#[allow(unused_imports)]")?;
    writeln!(
        &mut output,
        "use crate::gui::speed_controls::SpeedControls;"
    )?;
    writeln!(&mut output, "#[allow(unused_imports)]")?;
    writeln!(&mut output, "use crate::gui::topbar::TopBar;")?;
    writeln!(&mut output)?;

    // Generate panel rendering method
    let panel_code = generate_panel_from_tree(panel_name, tree)?;
    writeln!(&mut output, "{}", panel_code)?;

    Ok(output)
}

/// Generate rendering code from a GUI element tree.
fn generate_panel_from_tree(panel_name: &str, tree: &GuiElement) -> Result<String> {
    let panel_info = parser::extract_panel_info(tree, panel_name)?;
    generate_panel_renderer(&panel_info)
}

/// Generate a complete panel rendering using split load/render methods.
fn generate_panel_renderer(panel: &PanelInfo) -> Result<String> {
    let mut code = String::new();

    // Generate both load and render methods
    writeln!(&mut code, "impl GuiRenderer {{")?;

    // Generate load method
    let load_method = generate_load_method(panel)?;
    writeln!(&mut code, "{}", load_method)?;
    writeln!(&mut code)?;

    // Generate render method
    let render_method = generate_render_method(panel)?;
    writeln!(&mut code, "{}", render_method)?;

    writeln!(&mut code, "}}")?;

    Ok(code)
}

/// Generate sprite loading method (mutable borrow of widget_cache).
fn generate_load_method(panel: &PanelInfo) -> Result<String> {
    let mut code = String::new();

    let method_name = format!("load_{}_sprites", panel.name.replace('-', "_"));

    writeln!(&mut code, "    pub(crate) fn {}(", method_name)?;
    writeln!(&mut code, "        widget_cache: &mut WidgetCache,")?;
    writeln!(&mut code, "        gfx_db: &GfxDatabase,")?;
    writeln!(&mut code, "        sprite_cache: &mut SpriteCache,")?;
    writeln!(&mut code, "        device: &wgpu::Device,")?;
    writeln!(&mut code, "        queue: &wgpu::Queue,")?;
    writeln!(&mut code, "        sprite_renderer: &SpriteRenderer,")?;
    writeln!(&mut code, "    ) {{")?;

    writeln!(
        &mut code,
        "        // Load all sprites for {} panel",
        panel.name
    )?;

    for widget in &panel.widgets {
        if needs_sprite(widget) {
            let sprite_name = widget.sprite_name.as_ref().unwrap();
            writeln!(&mut code, "        widget_cache.get_or_load_sprite(")?;
            writeln!(&mut code, "            \"{}\",", sprite_name)?;
            writeln!(&mut code, "            gfx_db,")?;
            writeln!(&mut code, "            sprite_cache,")?;
            writeln!(&mut code, "            device,")?;
            writeln!(&mut code, "            queue,")?;
            writeln!(&mut code, "            sprite_renderer,")?;
            writeln!(&mut code, "        );")?;
        }
    }

    writeln!(&mut code, "    }}")?;

    Ok(code)
}

/// Generate rendering method (immutable borrow of widget_cache, tied to 'a).
fn generate_render_method(panel: &PanelInfo) -> Result<String> {
    let mut code = String::new();

    let method_name = format!("render_{}", panel.name.replace('-', "_"));

    // Determine panel type
    let panel_type = match panel.name.as_str() {
        "left" => "CountrySelectLeftPanel",
        "top" => "CountrySelectTopPanel",
        "right" | "country_selection_panel" => "CountrySelectRightPanel",
        "topbar" => "TopBar",
        "speed_controls" => "SpeedControls",
        _ => "CountrySelectRightPanel",
    };

    writeln!(&mut code, "    pub(crate) fn {}<'a>(", method_name)?;
    writeln!(&mut code, "        screen_size: (u32, u32),")?;
    writeln!(&mut code, "        sprite_renderer: &'a SpriteRenderer,")?;
    writeln!(&mut code, "        render_pass: &mut wgpu::RenderPass<'a>,")?;
    writeln!(&mut code, "        queue: &wgpu::Queue,")?;
    writeln!(&mut code, "        panel: &{},", panel_type)?;
    writeln!(&mut code, "        widget_cache: &'a WidgetCache,")?;
    writeln!(&mut code, "        hit_boxes: &mut Vec<(String, HitBox)>,")?;
    writeln!(&mut code, "    ) {{")?;

    writeln!(&mut code, "        // Render {} panel", panel.name)?;

    // Generate window anchor
    writeln!(
        &mut code,
        "        let window_anchor = get_window_anchor({:?}, Orientation::{:?}, screen_size);",
        panel.window_pos, panel.window_orientation
    )?;
    writeln!(&mut code)?;

    // Collect hit boxes
    writeln!(&mut code, "        let mut local_hit_boxes = Vec::new();")?;
    writeln!(&mut code)?;

    // Render all widgets
    for widget in &panel.widgets {
        if needs_sprite(widget) {
            let sprite_name = widget.sprite_name.as_ref().unwrap();
            let sprite_var = format!("sprite_{}", widget.name.to_lowercase().replace('-', "_"));

            writeln!(&mut code, "        // Widget: {}", widget.name)?;
            writeln!(
                &mut code,
                "        if let Some({}) = widget_cache.sprites.get(\"{}\") {{",
                sprite_var, sprite_name
            )?;

            let render_code = generate_widget_render(widget)?;
            writeln!(&mut code, "{}", render_code)?;

            writeln!(&mut code, "        }}")?;
            writeln!(&mut code)?;
        } else {
            writeln!(
                &mut code,
                "        // Text widget: {} (not yet implemented)",
                widget.name
            )?;
            writeln!(&mut code)?;
        }
    }

    // Register hit boxes
    writeln!(&mut code, "        // Register hit boxes")?;
    writeln!(&mut code, "        for cmd in local_hit_boxes {{")?;
    writeln!(
        &mut code,
        "            hit_boxes.push((cmd.name, cmd.hit_box));"
    )?;
    writeln!(&mut code, "        }}")?;

    writeln!(&mut code, "    }}")?;

    Ok(code)
}

/// Check if a widget needs sprite loading.
fn needs_sprite(widget: &WidgetInfo) -> bool {
    matches!(widget.widget_type, WidgetType::Button | WidgetType::Icon)
        && widget.sprite_name.is_some()
}

/// Generate rendering code for a single widget (Phase 2: render directly).
fn generate_widget_render(widget: &WidgetInfo) -> Result<String> {
    match widget.widget_type {
        WidgetType::Button => emit_button_render(widget),
        WidgetType::Icon => emit_icon_render(widget),
        WidgetType::TextBox | WidgetType::Listbox | WidgetType::EditBox => {
            // These widgets need special handling, skip for now
            Ok(format!(
                "        // TODO: Generate rendering for {} ({})",
                widget.name,
                widget_type_str(widget.widget_type)
            ))
        }
        WidgetType::Window => Ok(String::new()), // Windows don't render directly
    }
}

/// Generate button rendering code (Phase 2: render directly + collect hit box).
fn emit_button_render(widget: &WidgetInfo) -> Result<String> {
    let mut code = String::new();

    if let Some(_sprite_name) = &widget.sprite_name {
        let sprite_var = format!("sprite_{}", widget.name.to_lowercase().replace('-', "_"));
        let pos_var = format!("pos_{}", widget.name.to_lowercase().replace('-', "_"));

        // Calculate position
        // Use resolve_position for LOWER_* orientations (screen-relative)
        // Use position_from_anchor for other orientations (window-relative)
        let use_resolve = matches!(
            widget.orientation,
            eu4game::gui::types::Orientation::LowerLeft
                | eu4game::gui::types::Orientation::LowerRight
        );

        if use_resolve {
            writeln!(&mut code, "            let {} = resolve_position(", pos_var)?;
            writeln!(&mut code, "                {:?},", widget.position)?;
            writeln!(
                &mut code,
                "                Orientation::{:?},",
                widget.orientation
            )?;
            writeln!(&mut code, "                {}.dimensions,", sprite_var)?;
            writeln!(&mut code, "                screen_size")?;
            writeln!(&mut code, "            );")?;
        } else {
            writeln!(
                &mut code,
                "            let {} = position_from_anchor(",
                pos_var
            )?;
            writeln!(&mut code, "                window_anchor,")?;
            writeln!(&mut code, "                {:?},", widget.position)?;
            writeln!(
                &mut code,
                "                Orientation::{:?},",
                widget.orientation
            )?;
            writeln!(&mut code, "                {}.dimensions", sprite_var)?;
            writeln!(&mut code, "            );")?;
        }
        writeln!(&mut code)?;

        // Render sprite directly
        writeln!(&mut code, "            sprite_renderer.draw(")?;
        writeln!(&mut code, "                render_pass,")?;
        writeln!(
            &mut code,
            "                {}.bind_group.as_ref(),",
            sprite_var
        )?;
        writeln!(&mut code, "                queue,")?;
        writeln!(&mut code, "                {}.0,", pos_var)?;
        writeln!(&mut code, "                {}.1,", pos_var)?;
        writeln!(
            &mut code,
            "                {}.dimensions.0 as f32,",
            sprite_var
        )?;
        writeln!(
            &mut code,
            "                {}.dimensions.1 as f32,",
            sprite_var
        )?;
        writeln!(&mut code, "            );")?;
        writeln!(&mut code)?;

        // Collect hit box
        writeln!(&mut code, "            local_hit_boxes.push(HitBoxCmd {{")?;
        writeln!(
            &mut code,
            "                name: \"{}\".to_string(),",
            widget.name
        )?;
        writeln!(&mut code, "                hit_box: HitBox {{")?;
        writeln!(&mut code, "                    x: {}.0,", pos_var)?;
        writeln!(&mut code, "                    y: {}.1,", pos_var)?;
        writeln!(
            &mut code,
            "                    width: {}.dimensions.0 as f32,",
            sprite_var
        )?;
        writeln!(
            &mut code,
            "                    height: {}.dimensions.1 as f32,",
            sprite_var
        )?;
        writeln!(&mut code, "                }},")?;
        writeln!(&mut code, "            }});")?;
    }

    Ok(code)
}

/// Generate icon rendering code (Phase 2: render directly).
/// Icons don't have hit boxes, only sprite draws.
fn emit_icon_render(widget: &WidgetInfo) -> Result<String> {
    let mut code = String::new();

    if let Some(_sprite_name) = &widget.sprite_name {
        let sprite_var = format!("sprite_{}", widget.name.to_lowercase().replace('-', "_"));
        let pos_var = format!("pos_{}", widget.name.to_lowercase().replace('-', "_"));

        // Calculate position
        // Use resolve_position for LOWER_* orientations (screen-relative)
        // Use position_from_anchor for other orientations (window-relative)
        let use_resolve = matches!(
            widget.orientation,
            eu4game::gui::types::Orientation::LowerLeft
                | eu4game::gui::types::Orientation::LowerRight
        );

        if use_resolve {
            writeln!(&mut code, "            let {} = resolve_position(", pos_var)?;
            writeln!(&mut code, "                {:?},", widget.position)?;
            writeln!(
                &mut code,
                "                Orientation::{:?},",
                widget.orientation
            )?;
            writeln!(&mut code, "                {}.dimensions,", sprite_var)?;
            writeln!(&mut code, "                screen_size")?;
            writeln!(&mut code, "            );")?;
        } else {
            writeln!(
                &mut code,
                "            let {} = position_from_anchor(",
                pos_var
            )?;
            writeln!(&mut code, "                window_anchor,")?;
            writeln!(&mut code, "                {:?},", widget.position)?;
            writeln!(
                &mut code,
                "                Orientation::{:?},",
                widget.orientation
            )?;
            writeln!(&mut code, "                {}.dimensions", sprite_var)?;
            writeln!(&mut code, "            );")?;
        }
        writeln!(&mut code)?;

        // Render sprite directly (icons don't have hit boxes)
        writeln!(&mut code, "            sprite_renderer.draw(")?;
        writeln!(&mut code, "                render_pass,")?;
        writeln!(
            &mut code,
            "                {}.bind_group.as_ref(),",
            sprite_var
        )?;
        writeln!(&mut code, "                queue,")?;
        writeln!(&mut code, "                {}.0,", pos_var)?;
        writeln!(&mut code, "                {}.1,", pos_var)?;
        writeln!(
            &mut code,
            "                {}.dimensions.0 as f32,",
            sprite_var
        )?;
        writeln!(
            &mut code,
            "                {}.dimensions.1 as f32,",
            sprite_var
        )?;
        writeln!(&mut code, "            );")?;
    }

    Ok(code)
}

/// Convert widget type to string for comments.
fn widget_type_str(widget_type: WidgetType) -> &'static str {
    match widget_type {
        WidgetType::Button => "Button",
        WidgetType::TextBox => "TextBox",
        WidgetType::Icon => "Icon",
        WidgetType::Window => "Window",
        WidgetType::Listbox => "Listbox",
        WidgetType::EditBox => "EditBox",
    }
}
