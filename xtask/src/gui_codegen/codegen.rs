//! Code generation for GUI panel rendering methods.
//!
//! Generates Rust code for `impl GuiRenderer` blocks with panel-specific rendering methods.

use super::parser;
use super::types::{PanelInfo, WidgetInfo, WidgetType};
use anyhow::{Context, Result};
use eu4game::gui::types::GuiElement;
use std::collections::HashMap;
use std::fmt::Write as FmtWrite;

/// Generate rendering code for a specific panel.
pub fn generate_panel(panel_name: &str, gui_trees: &HashMap<String, GuiElement>) -> Result<String> {
    // Find the window in the GUI trees
    let tree = gui_trees
        .get(panel_name)
        .with_context(|| format!("Panel '{}' not found in GUI trees", panel_name))?;

    let mut output = String::new();

    // Generate header
    writeln!(
        &mut output,
        "// AUTO-GENERATED by cargo xtask generate-gui-renderer"
    )?;
    writeln!(
        &mut output,
        "// Source: {} from parsed GUI files",
        panel_name
    )?;
    writeln!(&mut output, "// DO NOT EDIT - changes will be overwritten")?;
    writeln!(&mut output)?;

    // Generate panel rendering method
    let panel_code = generate_panel_from_tree(panel_name, tree)?;
    writeln!(&mut output, "{}", panel_code)?;

    Ok(output)
}

/// Generate rendering code from a GUI element tree.
fn generate_panel_from_tree(panel_name: &str, tree: &GuiElement) -> Result<String> {
    let panel_info = parser::extract_panel_info(tree, panel_name)?;
    generate_panel_renderer(&panel_info)
}

/// Generate a complete panel rendering method.
fn generate_panel_renderer(panel: &PanelInfo) -> Result<String> {
    let mut code = String::new();

    // Generate method signature
    writeln!(&mut code, "impl GuiRenderer {{")?;
    writeln!(
        &mut code,
        "    pub(crate) fn render_{}_generated(&mut self,",
        panel.name.replace('-', "_")
    )?;
    writeln!(
        &mut code,
        "        panel: &{},",
        panel_type_name(&panel.name)
    )?;
    writeln!(&mut code, "        screen_size: (u32, u32),")?;
    writeln!(&mut code, "        sprite_renderer: &SpriteRenderer,")?;
    writeln!(&mut code, "        render_pass: &mut wgpu::RenderPass<'_>,")?;
    writeln!(&mut code, "        device: &wgpu::Device,")?;
    writeln!(&mut code, "        queue: &wgpu::Queue,")?;
    writeln!(&mut code, "    ) {{")?;

    // Generate window anchor calculation
    writeln!(&mut code)?;
    writeln!(
        &mut code,
        "        let window_anchor = get_window_anchor({:?}, {:?}, screen_size);",
        panel.window_pos, panel.window_orientation
    )?;
    writeln!(&mut code)?;

    // Generate widget rendering code
    for widget in &panel.widgets {
        let widget_code = generate_widget_rendering(widget)?;
        writeln!(&mut code, "{}", widget_code)?;
    }

    writeln!(&mut code, "    }}")?;
    writeln!(&mut code, "}}")?;

    Ok(code)
}

/// Generate rendering code for a single widget.
fn generate_widget_rendering(widget: &WidgetInfo) -> Result<String> {
    match widget.widget_type {
        WidgetType::Button => emit_button_rendering(widget),
        WidgetType::TextBox => emit_text_rendering(widget),
        WidgetType::Icon => emit_icon_rendering(widget),
        WidgetType::Listbox | WidgetType::EditBox => {
            // These widgets need special handling, skip for now
            Ok(format!(
                "        // TODO: Generate rendering for {} ({})",
                widget.name,
                widget_type_str(widget.widget_type)
            ))
        }
        WidgetType::Window => Ok(String::new()), // Windows don't render directly
    }
}

/// Generate button rendering code.
fn emit_button_rendering(widget: &WidgetInfo) -> Result<String> {
    let mut code = String::new();

    writeln!(&mut code, "        // Button: {}", widget.name)?;
    writeln!(&mut code, "        {{")?;

    if let Some(sprite) = &widget.sprite_name {
        writeln!(
            &mut code,
            "            let sprite = self.widget_cache.get_or_load_sprite("
        )?;
        writeln!(&mut code, "                \"{}\",", sprite)?;
        writeln!(&mut code, "                &self.gfx_db,")?;
        writeln!(&mut code, "                &mut self.sprite_cache,")?;
        writeln!(&mut code, "                device,")?;
        writeln!(&mut code, "                queue,")?;
        writeln!(&mut code, "                sprite_renderer,")?;
        writeln!(&mut code, "            );")?;
        writeln!(&mut code, "            let pos = position_from_anchor(")?;
        writeln!(&mut code, "                window_anchor,")?;
        writeln!(&mut code, "                {:?},", widget.position)?;
        writeln!(&mut code, "                {:?},", widget.orientation)?;
        writeln!(&mut code, "                sprite.dimensions")?;
        writeln!(&mut code, "            );")?;
        writeln!(&mut code)?;
        writeln!(&mut code, "            // Render button sprite")?;
        writeln!(
            &mut code,
            "            sprite_renderer.draw(render_pass, &sprite.bind_group, pos, queue);"
        )?;
        writeln!(&mut code)?;
        writeln!(&mut code, "            // Register hit box")?;
        writeln!(
            &mut code,
            "            self.hit_boxes.push((\"{}\", HitBox {{",
            widget.name
        )?;
        writeln!(&mut code, "                x: pos.0, y: pos.1,")?;
        writeln!(
            &mut code,
            "                width: sprite.dimensions.0 as f32,"
        )?;
        writeln!(
            &mut code,
            "                height: sprite.dimensions.1 as f32,"
        )?;
        writeln!(&mut code, "            }}));")?;
    }

    writeln!(&mut code, "        }}")?;

    Ok(code)
}

/// Generate text rendering code.
fn emit_text_rendering(widget: &WidgetInfo) -> Result<String> {
    let mut code = String::new();

    writeln!(&mut code, "        // Text: {}", widget.name)?;
    writeln!(&mut code, "        {{")?;

    if let Some(font) = &widget.font {
        writeln!(
            &mut code,
            "            let text_content = panel.{}.text();",
            widget.name.replace('-', "_")
        )?;
        writeln!(
            &mut code,
            "            let text_to_render = if !text_content.is_empty() {{"
        )?;
        writeln!(&mut code, "                text_content")?;
        writeln!(&mut code, "            }} else {{")?;
        if let Some(default_text) = &widget.text {
            writeln!(&mut code, "                \"{}\"", default_text)?;
        } else {
            writeln!(&mut code, "                \"\"")?;
        }
        writeln!(&mut code, "            }};")?;
        writeln!(&mut code)?;
        writeln!(&mut code, "            if !text_to_render.is_empty() {{")?;
        writeln!(
            &mut code,
            "                // TODO: Implement font loading and text rendering"
        )?;
        writeln!(&mut code, "                // Font: {}", font)?;
        writeln!(
            &mut code,
            "                // Position: {:?}",
            widget.position
        )?;
        writeln!(
            &mut code,
            "                // Orientation: {:?}",
            widget.orientation
        )?;
        writeln!(&mut code, "            }}")?;
    }

    writeln!(&mut code, "        }}")?;

    Ok(code)
}

/// Generate icon rendering code.
fn emit_icon_rendering(widget: &WidgetInfo) -> Result<String> {
    let mut code = String::new();

    writeln!(&mut code, "        // Icon: {}", widget.name)?;
    writeln!(&mut code, "        {{")?;

    if let Some(sprite) = &widget.sprite_name {
        writeln!(
            &mut code,
            "            let sprite = self.widget_cache.get_or_load_sprite("
        )?;
        writeln!(&mut code, "                \"{}\",", sprite)?;
        writeln!(&mut code, "                &self.gfx_db,")?;
        writeln!(&mut code, "                &mut self.sprite_cache,")?;
        writeln!(&mut code, "                device,")?;
        writeln!(&mut code, "                queue,")?;
        writeln!(&mut code, "                sprite_renderer,")?;
        writeln!(&mut code, "            );")?;
        writeln!(&mut code, "            let pos = position_from_anchor(")?;
        writeln!(&mut code, "                window_anchor,")?;
        writeln!(&mut code, "                {:?},", widget.position)?;
        writeln!(&mut code, "                {:?},", widget.orientation)?;
        writeln!(&mut code, "                sprite.dimensions")?;
        writeln!(&mut code, "            );")?;
        writeln!(&mut code)?;
        writeln!(
            &mut code,
            "            sprite_renderer.draw(render_pass, &sprite.bind_group, pos, queue);"
        )?;
    }

    writeln!(&mut code, "        }}")?;

    Ok(code)
}

/// Convert panel name to Rust type name.
fn panel_type_name(panel_name: &str) -> &'static str {
    match panel_name {
        "left" => "CountrySelectLeftPanel",
        "top" => "CountrySelectTopPanel",
        "right" | "lobby_controls" => "LobbyControlsPanel",
        "topbar" => "TopBar",
        "speed_controls" => "SpeedControls",
        _ => "UnknownPanel",
    }
}

/// Convert widget type to string for comments.
fn widget_type_str(widget_type: WidgetType) -> &'static str {
    match widget_type {
        WidgetType::Button => "Button",
        WidgetType::TextBox => "TextBox",
        WidgetType::Icon => "Icon",
        WidgetType::Window => "Window",
        WidgetType::Listbox => "Listbox",
        WidgetType::EditBox => "EditBox",
    }
}
