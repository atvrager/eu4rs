"""Load EU4 training data from Cap'n Proto binary format.

This module provides type-safe loading of training samples generated by the Rust
simulation. It uses pycapnp to read the binary format defined in schemas/training.capnp.

Supports:
  - `.cpb` files: Single Cap'n Proto binary file
  - `.zip` files: ZIP archive containing multiple `.cpb` files (one per year)

Usage:
    from load_training_data import load_training_file, to_huggingface_dataset

    # Load from binary file or ZIP
    samples = load_training_file("training.cpb")
    samples = load_training_file("training.zip")

    # Convert to HuggingFace Dataset
    dataset = to_huggingface_dataset(samples)
"""

from __future__ import annotations

import argparse
import zipfile
from dataclasses import dataclass
from pathlib import Path
from typing import Iterator

import capnp

# Load the Cap'n Proto schema
# Schema is in ../schemas/training.capnp relative to this file
SCHEMA_PATH = Path(__file__).parent.parent / "schemas" / "training.capnp"
training_capnp = capnp.load(str(SCHEMA_PATH))


@dataclass
class Date:
    """Game date (year/month/day)."""

    year: int
    month: int
    day: int

    @classmethod
    def from_capnp(cls, reader) -> "Date":
        return cls(year=reader.year, month=reader.month, day=reader.day)

    def __str__(self) -> str:
        return f"{self.year}.{self.month}.{self.day}"


@dataclass
class Fixed:
    """Fixed-point number (raw i64 value)."""

    raw: int

    @classmethod
    def from_capnp(cls, reader) -> "Fixed":
        return cls(raw=reader.raw)

    def to_float(self, scale: int = 1000) -> float:
        """Convert to float with given scale (default 1000 = 3 decimal places)."""
        return self.raw / scale


@dataclass
class CountryState:
    """Visible state of a country."""

    treasury: float
    manpower: float
    stability: int
    prestige: float
    army_tradition: float
    adm_mana: float
    dip_mana: float
    mil_mana: float
    adm_tech: int
    dip_tech: int
    mil_tech: int
    embraced_institutions: list[str]
    religion: str

    @classmethod
    def from_capnp(cls, reader) -> "CountryState":
        return cls(
            treasury=Fixed.from_capnp(reader.treasury).to_float(),
            manpower=Fixed.from_capnp(reader.manpower).to_float(),
            stability=reader.stability,
            prestige=Fixed.from_capnp(reader.prestige).to_float(),
            army_tradition=Fixed.from_capnp(reader.armyTradition).to_float(),
            adm_mana=Fixed.from_capnp(reader.admMana).to_float(),
            dip_mana=Fixed.from_capnp(reader.dipMana).to_float(),
            mil_mana=Fixed.from_capnp(reader.milMana).to_float(),
            adm_tech=reader.admTech,
            dip_tech=reader.dipTech,
            mil_tech=reader.milTech,
            embraced_institutions=list(reader.embracedInstitutions),
            religion=reader.religion,
        )


@dataclass
class VisibleWorldState:
    """The visible world state from a country's perspective."""

    date: Date
    observer: str
    own_country: CountryState
    at_war: bool
    known_countries: list[str]
    enemy_provinces: list[int]
    known_country_strength: dict[str, int]
    our_war_score: dict[int, float]

    @classmethod
    def from_capnp(cls, reader) -> "VisibleWorldState":
        # Convert list of entries to dict
        strength = {e.country: e.strength for e in reader.knownCountryStrength}
        war_score = {
            e.warId: Fixed.from_capnp(e.score).to_float() for e in reader.ourWarScore
        }

        return cls(
            date=Date.from_capnp(reader.date),
            observer=reader.observer,
            own_country=CountryState.from_capnp(reader.ownCountry),
            at_war=reader.atWar,
            known_countries=list(reader.knownCountries),
            enemy_provinces=list(reader.enemyProvinces),
            known_country_strength=strength,
            our_war_score=war_score,
        )


def command_to_string(cmd_reader) -> str:
    """Convert a Cap'n Proto Command to a human-readable string.

    Matches the schema in schemas/training.capnp.
    """
    which = cmd_reader.which()

    # Control commands
    if which == "pass_":
        return "Pass"
    elif which == "quit":
        return "Quit"

    # Military Movement (groups)
    elif which == "move":
        return (
            f"Move(army={cmd_reader.move.armyId}, dest={cmd_reader.move.destination})"
        )
    elif which == "moveFleet":
        return f"MoveFleet(fleet={cmd_reader.moveFleet.fleetId}, dest={cmd_reader.moveFleet.destination})"
    elif which == "embark":
        return f"Embark(army={cmd_reader.embark.armyId}, fleet={cmd_reader.embark.fleetId})"
    elif which == "disembark":
        return f"Disembark(army={cmd_reader.disembark.armyId}, dest={cmd_reader.disembark.destination})"
    elif which == "mergeArmies":
        return f"MergeArmies({list(cmd_reader.mergeArmies)})"
    elif which == "splitArmy":
        return f"SplitArmy(army={cmd_reader.splitArmy.armyId}, count={cmd_reader.splitArmy.regimentCount})"

    # War & Peace
    elif which == "declareWar":
        return f"DeclareWar(target={cmd_reader.declareWar.target}, cb={cmd_reader.declareWar.cb})"
    elif which == "offerPeace":
        return f"OfferPeace(war={cmd_reader.offerPeace.warId})"
    elif which == "acceptPeace":
        return f"AcceptPeace(war={cmd_reader.acceptPeace})"
    elif which == "rejectPeace":
        return f"RejectPeace(war={cmd_reader.rejectPeace})"

    # Tech & Institutions (plain values)
    elif which == "buyTech":
        tech_map = {0: "adm", 1: "dip", 2: "mil"}
        return f"BuyTech({tech_map.get(cmd_reader.buyTech, cmd_reader.buyTech)})"
    elif which == "embraceInstitution":
        return f"EmbraceInstitution({cmd_reader.embraceInstitution})"

    # Economic (groups)
    elif which == "buildInProvince":
        return f"Build(prov={cmd_reader.buildInProvince.province}, building={cmd_reader.buildInProvince.building})"
    elif which == "developProvince":
        dev = cmd_reader.developProvince
        dev_map = {0: "tax", 1: "production", 2: "manpower"}
        return f"Develop(prov={dev.province}, type={dev_map.get(dev.devType, dev.devType)})"

    # Colonization (plain province IDs)
    elif which == "startColony":
        return f"StartColony(prov={cmd_reader.startColony})"
    elif which == "abandonColony":
        return f"AbandonColony(prov={cmd_reader.abandonColony})"

    # Diplomacy - Outgoing (plain country tags)
    elif which == "offerAlliance":
        return f"OfferAlliance({cmd_reader.offerAlliance})"
    elif which == "breakAlliance":
        return f"BreakAlliance({cmd_reader.breakAlliance})"
    elif which == "offerRoyalMarriage":
        return f"OfferRoyalMarriage({cmd_reader.offerRoyalMarriage})"
    elif which == "breakRoyalMarriage":
        return f"BreakRoyalMarriage({cmd_reader.breakRoyalMarriage})"
    elif which == "requestMilitaryAccess":
        return f"RequestMilitaryAccess({cmd_reader.requestMilitaryAccess})"
    elif which == "cancelMilitaryAccess":
        return f"CancelMilitaryAccess({cmd_reader.cancelMilitaryAccess})"
    elif which == "setRival":
        return f"SetRival({cmd_reader.setRival})"
    elif which == "removeRival":
        return f"RemoveRival({cmd_reader.removeRival})"

    # Diplomacy - Responses (plain country tags)
    elif which == "acceptAlliance":
        return f"AcceptAlliance({cmd_reader.acceptAlliance})"
    elif which == "rejectAlliance":
        return f"RejectAlliance({cmd_reader.rejectAlliance})"
    elif which == "acceptRoyalMarriage":
        return f"AcceptRoyalMarriage({cmd_reader.acceptRoyalMarriage})"
    elif which == "rejectRoyalMarriage":
        return f"RejectRoyalMarriage({cmd_reader.rejectRoyalMarriage})"
    elif which == "grantMilitaryAccess":
        return f"GrantMilitaryAccess({cmd_reader.grantMilitaryAccess})"
    elif which == "denyMilitaryAccess":
        return f"DenyMilitaryAccess({cmd_reader.denyMilitaryAccess})"

    # Religion (plain province IDs or country tags)
    elif which == "assignMissionary":
        return f"AssignMissionary(prov={cmd_reader.assignMissionary})"
    elif which == "recallMissionary":
        return f"RecallMissionary(prov={cmd_reader.recallMissionary})"
    elif which == "convertCountryReligion":
        return f"ConvertReligion({cmd_reader.convertCountryReligion})"

    # Control
    elif which == "moveCapital":
        return f"MoveCapital(prov={cmd_reader.moveCapital})"

    else:
        return f"Unknown({which})"


@dataclass
class TrainingSample:
    """A single training sample for ML."""

    tick: int
    country: str
    state: VisibleWorldState
    available_commands: list[str]
    chosen_action: int
    chosen_command: str | None

    @classmethod
    def from_capnp(cls, reader) -> "TrainingSample":
        available = [command_to_string(cmd) for cmd in reader.availableCommands]
        chosen = (
            command_to_string(reader.chosenCommand)
            if reader.chosenAction >= 0
            else None
        )

        return cls(
            tick=reader.tick,
            country=reader.country,
            state=VisibleWorldState.from_capnp(reader.state),
            available_commands=available,
            chosen_action=reader.chosenAction,
            chosen_command=chosen,
        )

    def to_prompt(self) -> str:
        """Format this sample as a training prompt."""
        state = self.state
        date = state.date
        country = state.own_country

        lines = [
            f"Date: {date}",
            f"Country: {state.observer}",
            f"Treasury: {country.treasury:.1f}",
            f"Manpower: {country.manpower:.1f}",
            f"Stability: {country.stability}",
            f"Prestige: {country.prestige:.1f}",
            f"Tech: ADM {country.adm_tech} / DIP {country.dip_tech} / MIL {country.mil_tech}",
            f"Mana: ADM {country.adm_mana:.0f} / DIP {country.dip_mana:.0f} / MIL {country.mil_mana:.0f}",
            f"At War: {'Yes' if state.at_war else 'No'}",
            "",
            "Available Actions:",
        ]

        for i, cmd in enumerate(self.available_commands):
            lines.append(f"  [{i}] {cmd}")

        return "\n".join(lines)

    def to_completion(self) -> str:
        """Format the chosen action as a completion."""
        if self.chosen_command:
            return f"Action: [{self.chosen_action}] {self.chosen_command}"
        else:
            return f"Action: [{self.chosen_action}] Pass"


def load_training_file(path: Path | str) -> list[TrainingSample]:
    """Load all training samples from a Cap'n Proto file or ZIP archive.

    Supports:
      - `.cpb` files: Direct Cap'n Proto binary (TrainingFile message)
      - `.zip` files: ZIP archive with `.cpb` files inside (one TrainingBatch per file)

    Args:
        path: Path to .cpb file or .zip archive

    Returns:
        List of TrainingSample objects
    """
    path = Path(path)
    samples = []

    if path.suffix.lower() == ".zip":
        # ZIP archive containing .cpb files
        with zipfile.ZipFile(path, "r") as zf:
            # Sort for deterministic ordering
            names = sorted(n for n in zf.namelist() if n.endswith(".cpb"))
            for name in names:
                with zf.open(name) as f:
                    data = f.read()
                    # Use high traversal limit for large yearly batches (~500MB each)
                    batch = training_capnp.TrainingBatch.from_bytes_packed(
                        data, traversal_limit_in_words=2**30
                    )
                    for sample in batch.samples:
                        samples.append(TrainingSample.from_capnp(sample))
    else:
        # Single .cpb file (TrainingFile format)
        with open(path, "rb") as f:
            training_file = training_capnp.TrainingFile.read_packed(f)
            for batch in training_file.batches:
                for sample in batch.samples:
                    samples.append(TrainingSample.from_capnp(sample))

    return samples


def iter_training_file(path: Path | str) -> Iterator[TrainingSample]:
    """Iterate over training samples from a Cap'n Proto file or ZIP archive.

    Memory-efficient streaming version of load_training_file.

    Args:
        path: Path to .cpb file or .zip archive

    Yields:
        TrainingSample objects
    """
    path = Path(path)

    if path.suffix.lower() == ".zip":
        with zipfile.ZipFile(path, "r") as zf:
            names = sorted(n for n in zf.namelist() if n.endswith(".cpb"))
            for name in names:
                with zf.open(name) as f:
                    data = f.read()
                    # Use high traversal limit for large yearly batches
                    batch = training_capnp.TrainingBatch.from_bytes_packed(
                        data, traversal_limit_in_words=2**30
                    )
                    for sample in batch.samples:
                        yield TrainingSample.from_capnp(sample)
    else:
        with open(path, "rb") as f:
            training_file = training_capnp.TrainingFile.read_packed(f)
            for batch in training_file.batches:
                for sample in batch.samples:
                    yield TrainingSample.from_capnp(sample)


def to_huggingface_dataset(samples: list[TrainingSample]):
    """Convert training samples to a HuggingFace Dataset.

    Args:
        samples: List of TrainingSample objects

    Returns:
        datasets.Dataset with 'prompt' and 'completion' columns
    """
    from datasets import Dataset

    data = {"prompt": [], "completion": [], "country": [], "tick": []}

    for sample in samples:
        data["prompt"].append(sample.to_prompt())
        data["completion"].append(sample.to_completion())
        data["country"].append(sample.country)
        data["tick"].append(sample.tick)

    return Dataset.from_dict(data)


def print_sample_stats(samples: list[TrainingSample]) -> None:
    """Print statistics about loaded samples."""
    if not samples:
        print("No samples loaded.")
        return

    countries = {}
    actions = {}
    min_tick = samples[0].tick
    max_tick = samples[0].tick

    for s in samples:
        countries[s.country] = countries.get(s.country, 0) + 1
        actions[s.chosen_action] = actions.get(s.chosen_action, 0) + 1
        min_tick = min(min_tick, s.tick)
        max_tick = max(max_tick, s.tick)

    print(f"Total samples: {len(samples)}")
    print(f"Tick range: {min_tick} - {max_tick}")
    print(f"Year range: {1444 + min_tick // 365} - {1444 + max_tick // 365}")
    print()
    print("Top countries:")
    for country, count in sorted(countries.items(), key=lambda x: -x[1])[:10]:
        print(f"  {country}: {count}")
    print()
    print("Action distribution:")
    for action, count in sorted(actions.items()):
        pct = count / len(samples) * 100
        label = "Pass" if action == -1 else f"Action[{action}]"
        print(f"  {label}: {count} ({pct:.1f}%)")


def main():
    """CLI entry point for inspecting training data."""
    parser = argparse.ArgumentParser(
        description="Load and inspect Cap'n Proto training data"
    )
    parser.add_argument(
        "path", type=Path, help="Path to .cpb file or .zip archive of .cpb files"
    )
    parser.add_argument("--stats", "-s", action="store_true", help="Show statistics")
    parser.add_argument(
        "--samples", "-n", type=int, default=0, help="Show N sample prompts"
    )
    parser.add_argument("--country", "-c", type=str, help="Filter by country tag")

    args = parser.parse_args()

    if not args.path.exists():
        print(f"Error: File not found: {args.path}")
        return 1

    print(f"Loading {args.path}...")
    samples = load_training_file(args.path)

    if args.country:
        samples = [s for s in samples if s.country == args.country]
        print(f"Filtered to {len(samples)} samples for {args.country}")

    if args.stats:
        print_sample_stats(samples)

    if args.samples > 0:
        print(f"\n=== First {min(args.samples, len(samples))} samples ===\n")
        for sample in samples[: args.samples]:
            print("-" * 60)
            print(sample.to_prompt())
            print()
            print(sample.to_completion())
            print()

    return 0


if __name__ == "__main__":
    exit(main())
