# Generic UI Engine Design

**Status**: Draft
**Date**: 2025-12-31
**Last Updated**: 2025-12-31
**Objective**: Create a scalable, type-safe, and mod-friendly system for rendering EU4-style UI panels.

## 1. Problem Statement

The current UI implementation in `eu4game` handles panels (like the Topbar or Speed Controls) via manual layout extraction and string-matching comparisons (e.g., `if name == "text_gold"`).

**Issues**:
*   **Fragile**: Renaming a widget in a `.gui` file (or a mod doing so) silently breaks the binding.
*   **Repetitive**: Boilerplate code to parse position, size, and icons for every single panel.
*   **Missing Features**: Lack of scalable backgrounds (9-slice) limits visual fidelity.
*   **Hard to Test**: UI logic is tightly coupled to the existence of valid `.gui` files, complicating CI.

## 2. Constraints & Requirements

1.  **CI Compatible**: The build system (GitHub Actions) does **not** have access to copyright-protected EU4 game assets (`.gui` files). Code must compile and run (gracefully handling missing assets) without them.
2.  **Mod Support**: The engine must support runtime reloading or overriding of layouts. If a mod moves a button, the engine must respect the new position without recompilation.
3.  **Type Safety**: Rust logic typically needs to interact with specific known elements (e.g., "update the Gold text"). We want compile-time guarantees for these contracts where possible.

## 3. Architecture: The "Runtime Binder" Pattern

To balance type safety with runtime flexibility, we decouple the **View Contract** (Rust Struct) from the **Layout Definition** (File).

### 3.1 The View Contract (Rust)

We define what specific widgets the game code *needs* to interact with using a struct. We use a procedural macro `GuiWindow` to generate the binding logic, but **we do not parse the file at compile time**.

```rust
#[derive(GuiWindow)]
#[gui(window_name = "country_selection_panel")]
pub struct CountrySelectPanel {
    // We expect a text box named "selected_nation_label".
    // If the GUI file calls it something else, we use #[gui(name = "...")]
    #[gui(name = "selected_nation_label")]
    pub nation_name: GuiText,

    // We expect a button named "play_button".
    pub play_button: GuiButton,

    // We expect a background, but maybe we don't interact with it in logic.
    // It will render automatically if part of the layout, but we don't need a field.
}
```

### 3.2 The Layout Definition (File)

The standard `.gui` file remains the source of truth for **Position**, **Size**, **Sprite**, and **Hierarchy**.

```txt
windowType = {
    name = "country_selection_panel"
    position = { x=0 y=0 }
    
    instantTextBoxType = {
        name = "selected_nation_label"
        position = { x=24 y=130 }
        ...
    }
}
```

### 3.3 The Runtime Binder

At application startup (or when entering a state):

1.  **Parse**: The generic `GuiParser` loads `interface/frontend.gui` into a generic `GuiTree` (hierarchy of nodes).
2.  **Bind**: The `CountrySelectPanel::new(&gui_tree)` method (generated by the macro) walks the tree.
    *   It looks for a node named `"selected_nation_label"`.
    *   **Found**: It creates a `GuiText` handle pointing to that node's render data.
    *   **Not Found** (or CI environment): It creates a `GuiText` in a "detached" or "broken" state. Method calls like `.set_text()` simply do nothing.
    *   **Binding Report**: The engine logs warnings: "UI Warning: Expected widget 'play_button' not found in layout 'country_selection_panel'".

**Result**: 
*   **CI**: Passes. Structs exist. Logic runs. "Detached" widgets absorb calls silently.
*   **Mods**: If a mod moves the label to `{ x=900 y=900 }`, the Binder still finds it by name. The View renders at the new position automatically.

### 3.4 Handling Unimplemented Widgets
*Strategy: Graceful Degradation*

In CI environments (missing assets) or when a mod introduces new widget types our engine doesn't support yet, the system must not crash.

1.  **Missing Nodes**: If `binder.bind_text("foo")` fails to find "foo", it returns a `GuiText::placeholder()`. Calls to `.set_text()` on this placeholder are no-ops.
2.  **Unknown Types**: The Parser will eventually encounter types like `animatedIconType`. It should parse them into a generic `GuiElement::Unknown { raw_props: HashMap }` node. The renderer skips them, logging a "once-per-session" warning.

### 3.5 Mixed-Mode & Template Parsing
`frontend.gui` reveals a pattern where small, re-usable window definitions (like `dlc_entry` or `frontend_link_item`) are defined at the top level, *alongside* the main `country_selection_panel`.

*   **Requirement**: The Parser must not assume a single root window. It needs to expose a `Database` of windows, where some are "Root Views" (like the Country Select screen) and others are "Templates" (instantiated programmatically by listboxes).

### 3.6 Input Handling Model

UI input follows a **single-pass hit-test** model rather than event bubbling/capturing (which adds complexity we don't need for EU4's relatively flat UI).

**Hit Testing Order:**
1.  **Back-to-Front**: Widgets are tested in reverse render order (topmost first).
2.  **First Hit Wins**: The first widget whose bounds contain the cursor receives the event.
3.  **Consumption**: Widgets return `EventResult::Consumed` or `EventResult::Ignored`.

**Event Flow:**
```
MouseClick at (x, y)
    │
    ▼
┌─────────────────────────────────────────┐
│ UiRoot.handle_input(event)              │
│   for window in windows.iter().rev() {  │  ← Reverse order (top to bottom)
│     if window.hit_test(x, y) {          │
│       match window.handle_input(event) {│
│         Consumed => return Consumed,    │
│         Ignored  => continue,           │
│       }                                 │
│     }                                   │
│   }                                     │
│   Ignored                               │
└─────────────────────────────────────────┘
```

**Focus Management:**
*   `GuiEditBox` and similar widgets require keyboard focus.
*   A single `Option<WidgetId>` tracks the focused widget.
*   Clicking outside clears focus; clicking a focusable widget transfers it.
*   `Tab` navigation is deferred (not needed for MVP).

### 3.7 Z-Ordering & Layering

EU4 UI uses implicit z-ordering based on:
1.  **Parse Order**: Widgets defined later in `.gui` files render on top.
2.  **Window Layers**: Some windows are explicitly "always on top" (tooltips, modals).

**Implementation:**
*   `WindowDatabase` maintains a `Vec<WindowId>` representing render order.
*   `bring_to_front(id)` moves a window to the end of the vector.
*   Modal dialogs push a "blocker" that absorbs input for windows below.

**Layer Categories:**
| Layer | Z-Range | Examples |
|-------|---------|----------|
| Background | 0-99 | Map, terrain |
| Panels | 100-199 | Topbar, sidebars |
| Windows | 200-299 | Province view, diplomacy |
| Modals | 300-399 | Confirmation dialogs |
| Tooltips | 400-499 | Hover info |
| Debug | 500+ | FPS counter, debug overlays |

### 3.8 Localization Integration

EU4 uses `$KEY$` tokens in text that resolve to localized strings at runtime.

**Strategy: Lazy Resolution**
*   `GuiText` stores the *raw* string (may contain `$KEY$` tokens).
*   At render time, the `TextRenderer` calls `Localizer::resolve(&raw)`.
*   Cache resolved strings with a generation counter; invalidate on language change.

**The Localizer Trait:**
```rust
pub trait Localizer: Send + Sync {
    /// Resolve a potentially-localized string.
    /// Returns the input unchanged if no keys found or in CI mode.
    fn resolve(&self, text: &str) -> Cow<str>;

    /// Current language code (e.g., "l_english").
    fn language(&self) -> &str;
}

/// CI-safe default: returns input unchanged.
pub struct NoOpLocalizer;
impl Localizer for NoOpLocalizer {
    fn resolve(&self, text: &str) -> Cow<str> { Cow::Borrowed(text) }
    fn language(&self) -> &str { "l_english" }
}
```

**Integration Points:**
*   `GuiText::render()` calls `ctx.localizer.resolve(&self.raw_text)`.
*   `set_text()` stores raw; `set_localized(key)` stores `$key$` wrapper.

---

## 4. Components

### 4.1 Building Blocks (Primitives)

We need a standard library of UI primitives that know how to render themselves.

*   `GuiElement`: Enum/Trait for generic rendering.
*   `GuiText`: Handle to mutable text content.
*   `GuiIcon`: Handle to sprite, frame, and visibility.
*   `GuiButton`: Handle for click detection and state (Up/Down/Hover).
*   **New**: `Gui9Slice` (CorneredTile): Backgrounds that scale.

### 4.2 The 9-Slice Renderer (Technical Gap)

Current renderers handle static sprites. We lack `CorneredTileSprite` support.

*   **Logic**: A 9-slice sprite defined by `size` and `borderSize`.
*   **Implementation**: A function that generates 9 quads (top-left, top, top-right, etc.) with UVs sliced accordingly.
*   **Integration**: Add `render_cornered_tile()` to `SpriteRenderer`.

### 4.3 Data Binding (Explicit)

We avoid "magic" reflection binding (e.g., tying a variable string name to a struct field name at runtime). It is brittle and hard to debug.
We use **Explicit Update Loops**.

```rust
impl CountrySelectPanel {
    pub fn update(&mut self, state: &SelectedCountryState) {
        // Explicit: The code clearly states WHAT goes WHERE.
        self.nation_name.set_text(&state.name);
        
        // Complex logic is easy:
        if state.is_playable {
            self.play_button.set_enabled(true);
        } else {
            self.play_button.set_enabled(false);
            self.play_button.set_tooltip("Cannot play this country");
        }
    }
}
```

### 4.4 Future Primitives (Deferred)

Analysis of `parser.rs` reveals several other standard EU4 types we will need eventually:

*   **GuiList / ScrollArea**: (`listboxType`, `smoothListboxType`). Critical for dynamic lists of armies, provinces, etc.
*   **GuiCheckBox**: (`checkboxType`). A button with a toggled state.
*   **GuiEditBox**: (`editBoxType`). For text input.
*   **GuiPieChart**: EU4 has no native `pieChartType`. Ledger pie charts are rendered by the engine directly to a texture displayed via `iconType`. We'd implement similarly: custom render to texture, bind to icon.
*   **GuiGrid**: (`gridBoxType`). Arranges children in a dynamic grid (Estates, HRE).
*   **Animations**: Properties like `show_position` and `animation_time` require a Transition system.

*These are out of scope for the initial engine but should fit the `GuiElement` trait architecture.*

---

## 5. Implementation Roadmap

### Phase 1: Foundational Rendering
1.  **Implement 9-Slice Renderer**: We cannot faithfully render panel backgrounds without this.
2.  **Refactor Sprite Cache**: Ensure `CorneredTileSprite` is properly loaded and accessible.

### Phase 2: The Binding System
1.  **Define Structs**: Create `GuiText`, `GuiIcon`, etc. types that hold a ref-counted pointer (or index) to the render state.
2.  **Implement Parser**: Ensure `parser.rs` output can be searched efficiently by name.
3.  **Manual Prototype**: Manually write one panel (e.g., TopBar) using the "Binder" pattern to prove the concept without writing the macro yet.

### Phase 3: The Macro (Optimization)
1.  **Create Macro**: Write `#[derive(GuiWindow)]` to generate the boilerplate lookup code (`tree.find_child("name")`).
2.  **Port Panels**: Convert `CountrySelect` and `SpeedControls` to use the macro.

---

## 6. Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| **Missing Assets (CI)** | The "Binder" must never panic on missing nodes. It must return "No-Op" handles. |
| **Duplicate Names** | Some EU4 files reuse names. The Binder should support hierarchical search (find "icon" *inside* "window_A"). |
| **Performance (Binding)** | Binding happens only once (at creation). Update loop is cheap (direct memory writes). |
| **Performance (Deep Hierarchies)** | EU4 panels nest 10+ levels deep. Use iterative traversal with explicit stack, not recursion. Cache flattened widget lists for hit-testing. |
| **String Lookup Cost** | Widget lookups by name happen frequently. Intern strings into a `StringInterner` and compare `SymbolId` integers instead of string slices. |
| **9-Slice Degenerate Cases** | If `target_size < 2 * border_size`, the math produces negative/overlapping quads. Fall back to simple stretch for undersized targets. |
| **Focus State Corruption** | Widget deletion while focused leaves dangling `WidgetId`. Clear focus when removing widgets; use generational indices. |
| **Mod Compatibility** | Mods may add unknown widget types or properties. Parser must skip unknown fields gracefully, logging warnings once per type. |

---

## 7. Detailed Implementation Plan

### Phase 1: 9-Slice Rendering Foundation
*Objective: Enable scalable UI backgrounds (CorneredTileSprite).*

- [x] **1.1. Refactor Sprite Cache** (`eu4game/src/gui/sprite_cache.rs`)
    - [x] Create `enum CachedSpriteType { Standard(Texture), Cornered(Texture, Border) }`.
    - [x] Implement `get_cornered_sprite(path, border_size)` method.
    - [x] Update `resolve_texture_path` to handle 9-slice naming conventions if unique.
- [x] **1.2. Implement Mesh Generator** (`eu4game/src/gui/nine_slice.rs`)
    - [x] Implement `generate_9_slice_quads(pos, size, border, texture_size) -> NineSliceResult`.
    - [x] Handle degenerate case: if `size < 2 * border`, return `NineSliceResult::Fallback(single_quad)`.
    - [x] *Detail*: Center quad stretches. Corner quads are fixed size. Edge quads stretch in one axis.
    - [x] Add unit tests for: normal case, degenerate case, zero border (should produce single quad).
- [x] **1.3. Update Renderer** (`eu4game/src/gui/mod.rs`)
    - [x] Add `draw_cornered_tile(&self, ...)` to `SpriteRenderer`.
    - [x] **Verification**: Render `GFX_country_selection_panel_bg` (the background) in `CountrySelectPanel` using the new renderer.

### Phase 2: The Generic UI Binder
*Objective: Decouple Rust code from specific .gui file content.*

- [x] **2.1. Define Core Traits** (`eu4game/src/gui/core.rs`)
    - [x] `trait GuiWidget`: Base trait for interactive widgets. Methods: `render(&self, ctx: &mut RenderContext)`, `handle_input(&mut self, event: &UiEvent) -> EventResult`.
    - [x] `struct UiContext`: Holds global state (mouse pos, time, localizer) passed to render calls.
    - [x] `enum EventResult { Consumed, Ignored }`: Return type for input handling.
    - [x] `struct WidgetId(u32, u32)`: Generational index for safe widget references.
- [x] **2.2. Implement Basic Primitives** (`eu4game/src/gui/primitives/`)
    - [x] `GuiText`: Wrapper around `TextBox`. Holds raw string, resolves localization at render.
    - [x] `GuiIcon`: Wrapper around `Icon`. Holds frame index, visibility, tint color.
    - [x] `GuiButton`: Wrapper around `Button`. Tracks `ButtonState { Normal, Hovered, Pressed, Disabled }`.
    - [x] `GuiContainer`: Wrapper for `windowType`. Holds children, handles recursive render/input.
    - [x] Each primitive implements `GuiWidget` trait and `placeholder()` constructor for CI fallback.
- [x] **2.3. The Binder System** (`eu4game/src/gui/binder.rs`)
    - [x] `struct Binder<'a>`: Holds reference to parsed `GuiNode` tree.
    - [x] `fn bind<T: Bindable>(&self, name: &str) -> T`: Generic binding with type inference.
    - [x] `fn bind_optional<T: Bindable>(&self, name: &str) -> Option<T>`: For optional widgets (no warning on miss).
    - [x] Iterative tree traversal (explicit stack) to handle deep nesting without stack overflow.
- [x] **2.4. String Interning** (`eu4game/src/gui/interner.rs`)
    - [x] Implement `StringInterner` with `intern(&str) -> Symbol` and `resolve(Symbol) -> &str`.
    - [x] Widget names stored as `Symbol` for O(1) comparison.
    - [x] Pre-intern common names ("icon", "text", "button") at startup.
- [x] **2.5. Template & Multi-Window Support**
    - [x] **Task**: Update `GuiParser` to produce a `WindowDatabase` (Map<Symbol, Window>) instead of a flat list.
    - [x] **Task**: Handle "Mixed-Mode" files (e.g., `frontend.gui`) where templates coexist alongside main panels.
    - [x] **Task**: Implement `instantiate_template(name) -> GuiContainer` for dynamic lists (clones template subtree).

### Phase 3: Macro & Data Binding
*Objective: Remove boilerplate and enforce type safety.*

- [x] **3.1. Macro Skeleton** (`eu4_macros crate`)
    - [x] `cargo new eu4_macros --lib --proc-macro`.
    - [x] Implement `#[derive(GuiWindow)]` primitive parser.
- [x] **3.2. Macro Logic**
    - [x] Generate `pub struct MyPanel` fields.
    - [x] Generate `impl MyPanel { pub fn bind(root: &GuiNode) -> Self }`.
- [x] **3.3. Verify & Migrate**
    - [x] Migrate `CountrySelectPanel` to use `#[derive(GuiWindow)]`.
    - [x] Verify identical behavior in-game.

### Phase 3.5: Production Migration
*Objective: Replace all legacy UI implementations with macro-based versions.*

- [x] **3.5.1. TopBar Migration**
    - [x] Create `TopBar` struct with `#[derive(GuiWindow)]` binding to topbar widgets
    - [x] Implement `update(&mut self, resources: &CountryResources)` method
    - [x] Replace legacy `TopBar` struct in `gui/mod.rs`
    - [x] Update `render_topbar()` to use macro-based implementation
    - [x] Verify topbar snapshot test still passes
- [x] **3.5.2. SpeedControls Migration**
    - [x] Create `SpeedControls` struct with `#[derive(GuiWindow)]` binding to speed panel widgets
    - [x] Implement `update(&mut self, speed: SimSpeed, paused: bool)` method
    - [x] Replace legacy `SpeedControls` struct in `gui/mod.rs`
    - [x] Update `render_speed_controls()` to use macro-based implementation
    - [x] Verify speed controls snapshot test still passes
- [x] **3.5.3. CountrySelect Production Integration** ✅ (2025-12-31)
    - [x] Add `country_select_panel` field to `GuiRenderer`
    - [x] Create `load_country_select_split()` function (returns layout + root for binding)
    - [x] Update `render_country_select_only()` to call `panel.update(country_state)`
    - [x] Use panel widget values for dynamic icons (government_rank, religion_icon, techgroup_icon)
    - [x] Use panel widget values for all dynamic texts (selected_nation_label, ruler stats, etc.)
    - [x] Remove legacy `load_country_select()` and `find_singleplayer_window_in_node()` functions
    - [x] Verify country select snapshot test still passes (726 tests passed)
- [x] **3.5.4. Legacy Cleanup** ✅ (2025-12-31)
    - [x] Remove file-level `#![allow(dead_code)]` from GuiText and GuiIcon (actively used in production)
    - [x] Add targeted `#[allow(dead_code)]` to fields/methods used only in tests or reserved for future
    - [x] Keep file-level `#![allow(dead_code)]` on GuiButton and GuiContainer (reserved for Phase 4)
    - [x] Update primitives/mod.rs with production status documentation showing which primitives are active
    - [x] Add `#[allow(unused_imports)]` to GuiButton and GuiContainer exports (not yet used in production)
    - [x] Verify all 726 tests pass with cleaned up annotations

---

## Frontend Flow Goal

*Target Experience*: Launch → Main Menu → Single Player → Pick Country → Start Game

This mirrors the authentic EU4 experience. The phases below are ordered to achieve this goal incrementally.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           FRONTEND FLOW                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐     ┌─────────────────────────────────────────────┐   │
│  │  MAIN MENU   │     │         COUNTRY SELECTION SCREEN            │   │
│  │              │     │  ┌─────────┐ ┌───────────────┐ ┌─────────┐  │   │
│  │ [Single     ]│────▶│  │  LEFT   │ │     TOP       │ │  RIGHT  │  │   │
│  │  Player     ]│     │  │ ─────── │ │ ───────────── │ │ ─────── │  │   │
│  │ [Multiplayer]│     │  │Bookmarks│ │  Map Modes    │ │ Country │  │   │
│  │ [Tutorial   ]│     │  │Save List│ │  Start Date   │ │  Info   │  │   │
│  │ [Credits    ]│     │  │Date Pick│ │  Labels       │ │ Panel   │  │   │
│  │ [Exit       ]│     │  └─────────┘ └───────────────┘ │(already │  │   │
│  └──────────────┘     │                                │ done!)  │  │   │
│         │             │  ┌──────────────────────────┐  └─────────┘  │   │
│         │ [Back]◀─────│  │     [PLAY] Button        │               │   │
│                       │  └──────────────────────────┘               │   │
│                       └─────────────────────────────────────────────┘   │
│                                        │                                 │
│                                        ▼                                 │
│                              ┌──────────────────┐                        │
│                              │   GAME PLAYING   │                        │
│                              │   (existing!)    │                        │
│                              └──────────────────┘                        │
└─────────────────────────────────────────────────────────────────────────┘
```

**Current State (after Phase 6.1.1)**:
- ✅ CountrySelectPanel (right panel) - fully macro-based
- ✅ TopBar, SpeedControls - production integrated
- ✅ GuiButton primitive - with UiAction support
- ✅ GuiCheckbox primitive - with toggle state
- ✅ GuiEditBox primitive - with text input support
- ✅ MainMenuPanel - button bindings for frontend navigation
- ✅ UiAction enum - button click results
- ✅ Input system infrastructure (hit testing, focus management)
- ✅ Screen state machine (Screen enum, ScreenManager with navigation history)
- ✅ Panel visibility (GuiContainer with show/hide methods)
- ✅ UiRoot for input dispatch and focus management
- ✅ Frontend container (FrontendUI struct with screen management)
- ❌ Main loop integration (route rendering and input by screen)
- ❌ Left panel (bookmarks, save list, date picker)
- ❌ Top panel (map modes, labels)
- ❌ Listbox widget

---

### Phase 4: Button Integration & Interactive Primitives
*Objective: Make buttons work and add checkbox/editbox support.*

- [x] **4.1. GuiButton Production Integration**
    - [x] Create `MainMenuPanel` struct with button bindings (single_player, multiplayer, exit, etc.)
    - [x] Define `UiAction` enum for button click results (`ShowSinglePlayer`, `Exit`, etc.)
    - [x] Wire button clicks to action handlers via `poll_click()` method
    - [x] Integrate button hit boxes into unified input dispatch (moved to Phase 6.1.3)
- [x] **4.2. Checkbox Support** (`gui/primitives/checkbox.rs`)
    - [x] Parse `checkboxType` in GUI parser
    - [x] Implement `GuiCheckbox` struct with `checked: bool` state
    - [x] Handle click events to toggle state
    - [x] Support checkbox in macro binder (bindable via `GuiNode`)
- [x] **4.3. EditBox Support** (`gui/primitives/editbox.rs`)
    - [x] Parse `editBoxType` (used for date input, player name)
    - [x] Implement `GuiEditBox` with `String` buffer
    - [x] Handle keyboard focus and text input
    - [x] Support cursor positioning (left/right arrow keys)
    - [x] Support backspace and delete keys
    - [x] Enforce max_characters limit

### Phase 5: Input System & Focus Management
*Objective: Enable proper event handling and keyboard focus.*

- [x] **5.1. Event Types** (`eu4game/src/gui/core.rs`) ✅ (Already implemented)
    - [x] Define `UiEvent` enum: `MouseMove { x, y }`, `MouseButton { button, state, x, y }`, `KeyPress { key, modifiers }`, `TextInput { char }`
    - [x] Define `MouseButton` enum: `Left`, `Right`, `Middle`
    - [x] Define `ButtonState` enum: `Pressed`, `Released`
- [x] **5.2. Hit Testing** (`eu4game/src/gui/input.rs`) ✅ (2025-12-31)
    - [x] Implement `hit_test(x, y, widgets) -> Option<WidgetId>` function
    - [x] Define `HitTestEntry` struct for widget bounds tracking
    - [x] Traverse in reverse render order (topmost first)
- [x] **5.3. Focus Management** (`eu4game/src/gui/input.rs`) ✅ (2025-12-31)
    - [x] `struct FocusManager { focused: Option<WidgetId> }`
    - [x] `focus(id)`: Set focus, send `FocusLost` to previous, `FocusGained` to new
    - [x] `clear_focus()`: Remove focus from current widget
    - [x] Handle widget removal: if focused widget is removed, clear focus
    - [x] `generate_focus_events()`: Helper for creating focus transition events

### Phase 6: Screen & Panel Management
*Objective: Enable screen transitions and panel visibility control.*

- [x] **6.1. Screen State Machine** (`eu4game/src/screen.rs`) ✅ (2025-12-31)
    - [x] Define `Screen` enum: `MainMenu`, `SinglePlayer`, `Multiplayer`, `Playing`
    - [x] Define `ScreenManager` with `current_screen: Screen`
    - [x] `transition_to(screen)`: Handle screen changes with proper cleanup
    - [x] Navigation history stack for back button support
- [x] **6.2. Panel Visibility** (`gui/primitives/container.rs`) ✅ (2025-12-31)
    - [x] Add `visible: bool` property to `GuiContainer`
    - [x] Skip rendering hidden panels (early return in render)
    - [x] Skip hit testing for hidden panels (early return in handle_input)
    - [x] `show()`, `hide()`, `set_visible()`, `is_visible()` methods
- [x] **6.3. Input Dispatch Loop** (`gui/ui_root.rs`) ✅ (2025-12-31)
    - [x] Create `UiRoot` struct to manage panels and input routing
    - [x] `UiRoot::dispatch_event(event) -> Option<UiAction>`
    - [x] For mouse events: hit test → dispatch to widget → return action
    - [x] For keyboard events: dispatch to focused widget (if any)
    - [x] Integrate `FocusManager` from `gui/input.rs`
    - [x] Integrate `hit_test()` from `gui/input.rs`
    - [x] Focus event generation (`set_focus`, `clear_focus`, `handle_widget_removed`)
    - [x] Cache flattened widget bounds list, rebuild on layout change

### Phase 6.1: Frontend Integration
*Objective: Wire up Phase 6 infrastructure with actual panels and navigation.*

- [ ] **6.1.1. Frontend Container**
    - [x] Create `FrontendUI` struct containing all menu panels ✅ (2025-12-31)
    - [x] Add `MainMenuPanel` field (already exists) ✅ (2025-12-31)
    - [x] Integrate `ScreenManager` to control screen transitions ✅ (2025-12-31)
    - [x] Implement action handling for button clicks ✅ (2025-12-31)
    - [x] Add navigation history support (go_back, can_go_back) ✅ (2025-12-31)
    - [ ] Add `SinglePlayerPanel` placeholder (for future left/top/right panels)
    - [ ] Handle panel visibility based on current screen
- [ ] **6.1.2. Screen Integration in Main Loop**
    - [ ] Add `ScreenManager` to main game state
    - [ ] Route rendering based on current screen
    - [ ] Route input events through `UiRoot` based on current screen
- [ ] **6.1.3. Button Action to Screen Transition** (completes Phase 4.1 deferred task)
    - [ ] Wire `MainMenuPanel` button clicks to `ScreenManager.transition_to()`
    - [ ] `single_player` button → `Screen::SinglePlayer`
    - [ ] `exit` button → exit game
    - [ ] Return `UiAction` from button clicks through `UiRoot.dispatch_event()`
    - [ ] Integrate button hit boxes into `UiRoot` for unified input dispatch
- [ ] **6.1.4. Back Navigation**
    - [ ] Add back button to panels that need it
    - [ ] Wire back button to `ScreenManager.go_back()`
    - [ ] Escape key triggers back action (when not in text input)
    - [ ] Disable back navigation when in `Screen::Playing` (clear history)

### Phase 7: Listbox Support
*Objective: Enable scrollable lists for country/save selection.*

- [ ] **7.1. Parser Support**
    - [ ] Parse `listboxType` element in GUI parser
    - [ ] Extract: name, position, size, orientation, spacing, scrollbartype
    - [ ] Parse `scrollbarType` definitions from core.gui
    - [ ] Store listbox definitions in WindowDatabase
- [ ] **7.2. Entry Templates**
    - [ ] Parse entry template windows (e.g., `savegameentry`, `interesting_country`)
    - [ ] Support multiple widget types in entry: icon, text, button, checkbox
    - [ ] Entry templates define row height and layout
- [ ] **7.3. GuiListbox Primitive** (`gui/primitives/listbox.rs`)
    - [ ] `struct GuiListbox<T>` with item data binding
    - [ ] Adapter pattern: `trait ListAdapter { fn item_count(); fn bind_entry(idx, entry); }`
    - [ ] Scroll offset tracking (0.0 to max_scroll)
    - [ ] Visible item range calculation
- [ ] **7.4. Rendering**
    - [ ] Implement scissor rect clipping (wgpu::RenderPass::set_scissor_rect)
    - [ ] Only render items in visible range
    - [ ] Render entry widgets at calculated positions
    - [ ] Render scrollbar if content overflows
- [ ] **7.5. Interaction**
    - [ ] Mouse wheel scrolling
    - [ ] Click on item → selection callback
    - [ ] Scrollbar drag interaction
    - [ ] Keyboard navigation (up/down arrows, page up/down)

### Phase 8: Frontend Panels
*Objective: Build the complete main menu and country selection UI.*

- [ ] **8.1. Main Menu Panel** (`gui/frontend/main_menu.rs`)
    - [ ] Create `MainMenuPanel` with macro binding to `mainmenu` window
    - [ ] Bind buttons: single_player, multi_player, tutorial, credits, settings, exit
    - [ ] Logo and version text display
    - [ ] Button click → screen transition actions
- [ ] **8.2. Country Selection Left Panel** (`gui/frontend/country_select_left.rs`)
    - [ ] `CountrySelectLeftPanel` struct
    - [ ] Bookmarks listbox (historical start dates)
    - [ ] Save games listbox (if save support added)
    - [ ] Date widget (year/month/day editors)
    - [ ] Back button
- [ ] **8.3. Country Selection Top Panel** (`gui/frontend/country_select_top.rs`)
    - [ ] `CountrySelectTopPanel` struct
    - [ ] Map mode buttons (terrain, political, religion, etc.)
    - [ ] Start date label ("The World in 1444")
    - [ ] Nation selection prompt label
- [ ] **8.4. Play Button & Game Start**
    - [ ] Bind play_button from lobby/singleplayer area
    - [ ] Click → validate country selected → start game
    - [ ] Transition to Playing screen

### Phase 9: Game Integration
*Objective: Connect UI to game systems for complete start flow.*

- [ ] **9.1. Bookmark System**
    - [ ] Parse bookmarks from game data (historical start dates)
    - [ ] Populate bookmarks listbox
    - [ ] Bookmark selection updates start date
    - [ ] Bookmark selection may suggest default country
- [ ] **9.2. Country Selection Data Flow**
    - [ ] Map click → country selection (extend existing province click)
    - [ ] Listbox click → country selection
    - [ ] Selection updates `CountrySelectPanel` (already working)
    - [ ] Track `selected_country: Option<CountryTag>`
- [ ] **9.3. Game Initialization**
    - [ ] On Play click: validate selection (country selected, valid date)
    - [ ] Load world state for selected date
    - [ ] Set player country
    - [ ] Transition to Playing screen
    - [ ] Initialize simulation thread with selected state
- [ ] **9.4. Screen State Integration**
    - [ ] Replace current `GamePhase` enum with `Screen` system
    - [ ] Update main loop to use screen-based input routing
    - [ ] Menu screens don't advance simulation
    - [ ] Playing screen runs simulation normally

### Phase 10: Localization System
*Objective: Support EU4's $KEY$ localization tokens.*

- [ ] **10.1. Localizer Trait** (`eu4game/src/gui/localization.rs`)
    - [ ] Define `trait Localizer: Send + Sync`
    - [ ] Implement `NoOpLocalizer` for CI (returns input unchanged)
    - [ ] Implement `FileLocalizer` that loads from `localisation/*.yml`
- [ ] **10.2. Token Resolution**
    - [ ] Parse `$KEY$` tokens from strings
    - [ ] Handle nested tokens: `$KEY1$` resolves to `"Hello $KEY2$"`, which needs further resolution
    - [ ] Limit recursion depth (max 5) to prevent infinite loops from malformed data
- [ ] **10.3. Caching**
    - [ ] Cache resolved strings with `(raw_hash, language_gen) -> resolved` map
    - [ ] Invalidate cache on language change (bump generation counter)
- [ ] **10.4. Integration**
    - [ ] Add `localizer: Arc<dyn Localizer>` to `UiContext`
    - [ ] `GuiText::render()` calls `ctx.localizer.resolve()` before drawing

### Phase 11: Animation System
*Objective: Support EU4's UI animations and transitions.*

- [ ] **11.1. Transition Types** (`eu4game/src/gui/animation.rs`)
    - [ ] `PositionTransition`: Animate from `show_position` to `position`
    - [ ] `AlphaTransition`: Fade in/out
    - [ ] `FrameAnimation`: Cycle through sprite frames
- [ ] **11.2. Timing**
    - [ ] `animation_time` property support (EU4 uses ~300ms for panel slides)
    - [ ] Easing functions: `Linear`, `EaseIn`, `EaseOut`, `Decelerated` (EU4's default)
- [ ] **11.3. Panel Transitions**
    - [ ] Left panel slides from left (x animation)
    - [ ] Top panel slides from top (y animation)
    - [ ] Right panel slides from right (x animation)
- [ ] **11.4. Integration**
    - [ ] `GuiWidget::update(dt: f32)` for animation tick
    - [ ] Widgets with active animations request continuous redraw

### Phase 12: Advanced Views
*Objective: Additional complex widgets for game UI.*

- [ ] **12.1. Pie Charts** (`gui/primitives/chart.rs`)
    - [ ] *Note*: EU4 has no `pieChartType` widget. Ledger charts are engine-rendered.
    - [ ] Implement `PieChartRenderer` that generates geometry for slices
    - [ ] Either render to offscreen texture or draw directly in UI pass
    - [ ] Add hover detection for individual slices
- [ ] **12.2. Progress Bars**
    - [ ] Parse progress bar widgets if used
    - [ ] Animate fill based on bound value
- [ ] **12.3. Tooltips**
    - [ ] Hover detection with delay
    - [ ] Tooltip panel positioning (avoid screen edges)
    - [ ] Dynamic tooltip content binding

### Phase 13: Code Health & Cleanup
*Objective: Remove transitional debt and stabilize the UI engine.*

- [ ] **13.1. Dead Code Audit**
    - [ ] Audit all `#![allow(dead_code)]` and `#[allow(dead_code)]` added during Phase 2-4
    - [ ] Ensure all primitives and binder methods are properly used
    - [ ] Delete unused placeholder code
- [ ] **13.2. Performance Audit**
    - [ ] Profile `Binder::find_node_iterative` in large UI files (e.g. `frontend.gui`)
    - [ ] Verify `WindowDatabase` lookup costs are negligible
    - [ ] Profile listbox rendering with many items
    - [ ] Ensure scissor rect doesn't cause excessive draw calls
- [ ] **13.3. Documentation & Stabilization**
    - [ ] Update this document to reflect final implementation
    - [ ] Add rustdoc comments to all public traits and methods
    - [ ] Ensure 100% test coverage for core binder and interner logic
    - [ ] Create integration tests for complete frontend flow

---

## 8. Code Sketches

These snippets serve as detailed specifications for implementation tasks.

### 8.1 9-Slice Geometry Generator (Phase 1)
```rust
// eu4game/src/gui/nine_slice.rs

pub struct Quad {
    pub pos: [f32; 2],
    pub size: [f32; 2],
    pub uv_pos: [f32; 2],
    pub uv_size: [f32; 2],
}

pub enum NineSliceResult {
    /// Normal 9-slice with all 9 quads.
    Full([Quad; 9]),
    /// Fallback for degenerate cases (size < 2*border).
    Fallback(Quad),
}

pub fn generate_9_slice_quads(
    pos: (f32, f32),
    size: (f32, f32),
    border: (f32, f32),
    texture_size: (f32, f32),
) -> NineSliceResult {
    // Handle degenerate case: target too small for borders
    if size.0 < 2.0 * border.0 || size.1 < 2.0 * border.1 {
        return NineSliceResult::Fallback(Quad {
            pos: [pos.0, pos.1],
            size: [size.0, size.1],
            uv_pos: [0.0, 0.0],
            uv_size: [1.0, 1.0],
        });
    }

    // Calculate vertex x-coordinates
    let x = [
        pos.0,                      // left edge
        pos.0 + border.0,           // left border end
        pos.0 + size.0 - border.0,  // right border start
        pos.0 + size.0,             // right edge
    ];

    // Calculate vertex y-coordinates
    let y = [
        pos.1,                      // top edge
        pos.1 + border.1,           // top border end
        pos.1 + size.1 - border.1,  // bottom border start
        pos.1 + size.1,             // bottom edge
    ];

    // Calculate UV coordinates (normalized)
    let border_u = border.0 / texture_size.0;
    let border_v = border.1 / texture_size.1;
    let u = [0.0, border_u, 1.0 - border_u, 1.0];
    let v = [0.0, border_v, 1.0 - border_v, 1.0];

    // Generate 9 quads: row-major order (TL, T, TR, L, C, R, BL, B, BR)
    let mut quads = [Quad::default(); 9];
    for row in 0..3 {
        for col in 0..3 {
            let idx = row * 3 + col;
            quads[idx] = Quad {
                pos: [x[col], y[row]],
                size: [x[col + 1] - x[col], y[row + 1] - y[row]],
                uv_pos: [u[col], v[row]],
                uv_size: [u[col + 1] - u[col], v[row + 1] - v[row]],
            };
        }
    }

    NineSliceResult::Full(quads)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_degenerate_falls_back() {
        let result = generate_9_slice_quads(
            (0.0, 0.0),
            (10.0, 10.0),  // size
            (20.0, 20.0),  // border bigger than size!
            (64.0, 64.0),
        );
        assert!(matches!(result, NineSliceResult::Fallback(_)));
    }

    #[test]
    fn test_zero_border_single_quad() {
        let result = generate_9_slice_quads(
            (0.0, 0.0),
            (100.0, 100.0),
            (0.0, 0.0),  // zero border
            (64.0, 64.0),
        );
        // With zero border, center quad covers everything
        if let NineSliceResult::Full(quads) = result {
            // Center quad (index 4) should be full size
            assert_eq!(quads[4].size, [100.0, 100.0]);
        }
    }
}
```

### 8.2 Core Traits (Phase 2)
```rust
// eu4game/src/gui/core.rs

use std::borrow::Cow;

/// Result of handling a UI event.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EventResult {
    /// Event was handled; stop propagation.
    Consumed,
    /// Event was not handled; continue to next widget.
    Ignored,
}

/// Generational index for safe widget references.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct WidgetId {
    pub index: u32,
    pub generation: u32,
}

/// Context passed to widgets during rendering and input handling.
pub struct UiContext<'a> {
    pub mouse_pos: (f32, f32),
    pub time: f32,
    pub delta_time: f32,
    pub localizer: &'a dyn Localizer,
    pub focused_widget: Option<WidgetId>,
}

/// Base trait for all interactive UI widgets.
pub trait GuiWidget {
    /// Render this widget and its children.
    fn render(&self, ctx: &UiContext, renderer: &mut dyn GuiRenderer);

    /// Handle an input event. Return `Consumed` to stop propagation.
    fn handle_input(&mut self, event: &UiEvent, ctx: &UiContext) -> EventResult;

    /// Get the bounding rectangle for hit testing.
    fn bounds(&self) -> Rect;

    /// Check if a point is within this widget's interactive area.
    fn hit_test(&self, x: f32, y: f32) -> bool {
        self.bounds().contains(x, y)
    }
}

/// Trait for widgets that can be bound from GUI files.
pub trait Bindable: Sized {
    /// Attempt to create from a GUI node.
    fn from_node(node: &GuiNode) -> Option<Self>;

    /// Create a placeholder that does nothing (for CI/missing assets).
    fn placeholder() -> Self;
}
```

### 8.3 The Binder with String Interning (Phase 2)
```rust
// eu4game/src/gui/binder.rs

use crate::gui::interner::{StringInterner, Symbol};

pub struct Binder<'a> {
    root: &'a GuiNode,
    interner: &'a StringInterner,
}

impl<'a> Binder<'a> {
    pub fn new(root: &'a GuiNode, interner: &'a StringInterner) -> Self {
        Self { root, interner }
    }

    /// Bind a widget by name. Logs warning and returns placeholder if not found.
    pub fn bind<T: Bindable>(&self, name: &str) -> T {
        match self.bind_optional(name) {
            Some(widget) => widget,
            None => {
                log::warn!("UI Binding Failed: '{}' not found in '{}'",
                    name, self.root.name());
                T::placeholder()
            }
        }
    }

    /// Bind a widget by name. Returns None if not found (no warning).
    pub fn bind_optional<T: Bindable>(&self, name: &str) -> Option<T> {
        let target_symbol = self.interner.intern(name);
        self.find_node_iterative(target_symbol)
            .and_then(|node| T::from_node(node))
    }

    /// Iterative tree traversal (avoids stack overflow on deep nesting).
    fn find_node_iterative(&self, target: Symbol) -> Option<&'a GuiNode> {
        let mut stack = vec![self.root];

        while let Some(node) = stack.pop() {
            if node.name_symbol() == target {
                return Some(node);
            }
            // Push children in reverse order so we visit them left-to-right
            for child in node.children().iter().rev() {
                stack.push(child);
            }
        }

        None
    }
}
```

### 8.4 Input Handling (Phase 5)
```rust
// eu4game/src/gui/input.rs

/// UI event types mapped from winit events.
#[derive(Debug, Clone)]
pub enum UiEvent {
    MouseMove { x: f32, y: f32 },
    MouseButton { button: MouseButton, state: ButtonState, x: f32, y: f32 },
    KeyPress { key: KeyCode, modifiers: Modifiers },
    TextInput { character: char },
    FocusGained,
    FocusLost,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MouseButton { Left, Right, Middle }

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ButtonState { Pressed, Released }

impl UiRoot {
    /// Dispatch an event to the appropriate widget.
    pub fn dispatch_event(&mut self, event: &UiEvent, ctx: &mut UiContext) -> EventResult {
        match event {
            UiEvent::MouseButton { x, y, .. } | UiEvent::MouseMove { x, y } => {
                // Hit test in reverse render order (topmost first)
                for window_id in self.render_order.iter().rev() {
                    if let Some(window) = self.windows.get_mut(window_id) {
                        if window.hit_test(*x, *y) {
                            match window.handle_input(event, ctx) {
                                EventResult::Consumed => return EventResult::Consumed,
                                EventResult::Ignored => continue,
                            }
                        }
                    }
                }
                EventResult::Ignored
            }
            UiEvent::KeyPress { .. } | UiEvent::TextInput { .. } => {
                // Keyboard events go to focused widget only
                if let Some(focused_id) = ctx.focused_widget {
                    if let Some(widget) = self.get_widget_mut(focused_id) {
                        return widget.handle_input(event, ctx);
                    }
                }
                EventResult::Ignored
            }
            _ => EventResult::Ignored,
        }
    }
}
```

### 8.5 Localization (Phase 6)
```rust
// eu4game/src/gui/localization.rs

use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::RwLock;

/// Trait for resolving $KEY$ tokens in UI strings.
pub trait Localizer: Send + Sync {
    fn resolve<'a>(&'a self, text: &'a str) -> Cow<'a, str>;
    fn language(&self) -> &str;
}

/// No-op localizer for CI environments (returns input unchanged).
pub struct NoOpLocalizer;

impl Localizer for NoOpLocalizer {
    fn resolve<'a>(&'a self, text: &'a str) -> Cow<'a, str> {
        Cow::Borrowed(text)
    }
    fn language(&self) -> &str { "l_english" }
}

/// File-based localizer that loads from EU4's localisation/*.yml files.
pub struct FileLocalizer {
    strings: HashMap<String, String>,
    language: String,
    cache: RwLock<LocalizationCache>,
}

struct LocalizationCache {
    resolved: HashMap<u64, String>,  // hash(raw) -> resolved
    generation: u32,
}

impl FileLocalizer {
    const MAX_RECURSION: usize = 5;

    pub fn resolve_recursive(&self, text: &str, depth: usize) -> String {
        if depth > Self::MAX_RECURSION {
            log::warn!("Localization recursion limit reached for: {}", text);
            return text.to_string();
        }

        let mut result = String::with_capacity(text.len());
        let mut chars = text.chars().peekable();

        while let Some(c) = chars.next() {
            if c == '$' {
                // Collect key until next '$'
                let key: String = chars.by_ref().take_while(|&c| c != '$').collect();
                if let Some(value) = self.strings.get(&key) {
                    // Recursively resolve in case value contains more tokens
                    result.push_str(&self.resolve_recursive(value, depth + 1));
                } else {
                    // Key not found, preserve original token
                    result.push('$');
                    result.push_str(&key);
                    result.push('$');
                }
            } else {
                result.push(c);
            }
        }

        result
    }
}

impl Localizer for FileLocalizer {
    fn resolve<'a>(&'a self, text: &'a str) -> Cow<'a, str> {
        // Fast path: no tokens
        if !text.contains('$') {
            return Cow::Borrowed(text);
        }

        // Check cache (read lock)
        let hash = fxhash::hash64(text);
        {
            let cache = self.cache.read().unwrap();
            if let Some(resolved) = cache.resolved.get(&hash) {
                // Cache hit - but we can't return a reference to cache contents
                // So we clone. Consider using an interning approach for hot paths.
                return Cow::Owned(resolved.clone());
            }
        }

        // Cache miss - resolve and store
        let resolved = self.resolve_recursive(text, 0);
        {
            let mut cache = self.cache.write().unwrap();
            cache.resolved.insert(hash, resolved.clone());
        }

        Cow::Owned(resolved)
    }

    fn language(&self) -> &str { &self.language }
}
```

### 8.6 Macro Expansion (Phase 3)
```rust
// User Code
#[derive(GuiWindow)]
#[gui(window = "topbar_window")]
struct TopBar {
    #[gui(name = "gold_text")]
    treasury: GuiText,

    #[gui(name = "manpower_text")]
    manpower: GuiText,

    #[gui(name = "speed_indicator", optional)]
    speed: Option<GuiIcon>,
}

// Generated Code (by proc-macro)
impl TopBar {
    pub fn bind(root: &GuiNode, interner: &StringInterner) -> Self {
        let binder = Binder::new(root, interner);
        Self {
            treasury: binder.bind("gold_text"),
            manpower: binder.bind("manpower_text"),
            speed: binder.bind_optional("speed_indicator"),
        }
    }
}

impl GuiWidget for TopBar {
    fn render(&self, ctx: &UiContext, renderer: &mut dyn GuiRenderer) {
        self.treasury.render(ctx, renderer);
        self.manpower.render(ctx, renderer);
        if let Some(ref speed) = self.speed {
            speed.render(ctx, renderer);
        }
    }

    fn handle_input(&mut self, event: &UiEvent, ctx: &UiContext) -> EventResult {
        // Buttons handle input; text/icons typically don't
        EventResult::Ignored
    }

    fn bounds(&self) -> Rect {
        // Return union of all child bounds (computed at bind time)
        self.cached_bounds
    }
}
```

