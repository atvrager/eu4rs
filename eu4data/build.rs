//! Build script for eu4data - auto-generates type definitions if missing.
//!
//! This ensures developers don't need to manually run `cargo xtask coverage --generate`
//! before building. The generated types are gitignored but created automatically.

// use std::path::Path;

#![allow(clippy::collapsible_if)]
use std::collections::{HashMap, HashSet};
use std::env;
use std::fs;

fn main() {
    println!("cargo:rerun-if-changed=src/generated/schema.rs");
    println!("cargo:rerun-if-changed=src/generated/categories.rs");
    println!("cargo:rerun-if-changed=src/generated/types"); // Re-run if files are deleted/added
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=EU4_GAME_PATH");

    let cwd = env::current_dir().unwrap();
    let schema_path = cwd.join("src/generated/schema.rs");
    let types_dir = cwd.join("src/generated/types");

    // Always ensure output directory exists
    if !types_dir.exists() {
        fs::create_dir_all(&types_dir).expect("Failed to create types directory");
    }

    if !schema_path.exists() {
        println!(
            "cargo:warning=Schema file not found at {:?}. Skipping generation.",
            schema_path
        );
        // Create placeholder mod.rs if missing to allow compilation
        let mod_rs = types_dir.join("mod.rs");
        if !mod_rs.exists() {
            fs::write(&mod_rs, "//! Placeholder\n").unwrap();
        }
        // Still generate manifest even if schema is missing
        generate_manifest();
        return;
    }

    // Read schema
    let schema_content = fs::read_to_string(&schema_path).expect("Failed to read schema.rs");

    // Parse schema and generate files
    let categories = parse_schema(&schema_content);
    let mut modules: Vec<String> = categories.keys().cloned().collect();
    modules.sort();

    let mut mod_content =
        String::from("// Auto-generated type definitions.\n// Generated by build.rs\n\n");
    for category_name in &modules {
        mod_content.push_str(&format!("pub mod {};\n", category_name.to_lowercase()));
        mod_content.push_str(&format!("pub use {}::*;\n", category_name.to_lowercase()));
    }

    // Generate helper to map DataCategory to fields
    mod_content.push('\n');
    mod_content.push_str("pub fn match_category_fields(category: crate::generated::categories::DataCategory) -> Option<&'static [crate::coverage::FieldInfo]> {\n");
    mod_content.push_str("    use crate::coverage::SchemaFields;\n");
    mod_content.push_str("    match category {\n");

    for category_name in &modules {
        // Category Name: "ImperialReforms" -> Variant: DataCategory::ImperialReforms
        // Module Name: "imperialreforms" -> Struct: ImperialReforms (via to_pascal_case)

        let module_name = category_name.to_lowercase();
        let struct_name = to_pascal_case(category_name);

        mod_content.push_str(&format!(
            "        crate::generated::categories::DataCategory::{} => Some({}::{}::fields()),\n",
            category_name, module_name, struct_name
        ));
    }

    mod_content.push_str("        _ => None,\n");
    mod_content.push_str("    }\n");
    mod_content.push_str("}\n");

    // Write module list to src/generated/types/module_list.rs (intermediate artifact, ignored)
    let module_list_path = types_dir.join("module_list.rs");
    fs::write(&module_list_path, mod_content).unwrap();

    // Write static placeholder mod.rs to src/ (stable, can be committed)
    let static_mod_path = types_dir.join("mod.rs");
    let static_content = "// Stable placeholder. Actual module list is in module_list.rs.\ninclude!(\"module_list.rs\");\n";
    fs::write(static_mod_path, static_content).unwrap();

    // Generate individual files
    for (category, fields) in &categories {
        let code = generate_struct_code(category, fields);
        let path = types_dir.join(format!("{}.rs", category.to_lowercase()));
        fs::write(&path, code).expect("Failed to write generated file");
    }

    // Generate manifest (Phase 2 integrity system)
    generate_manifest();
}

#[derive(Debug)]
struct Field {
    name: String,
    inferred_type: String, // String representation of InferredType enum e.g. "Integer"
    appears_multiple: bool,
    frequency: usize,
}

fn parse_schema(content: &str) -> HashMap<String, Vec<Field>> {
    let mut categories = HashMap::new();

    // Split by category blocks: DataCategory::Name => &[ ... ]
    let category_parts: Vec<&str> = content.split("DataCategory::").collect();

    for part in category_parts.iter().skip(1) {
        // Skip preamble
        let category_name = part.split(" =>").next().unwrap().trim().to_string(); // e.g. Advisortypes or ImperialReforms

        // Find the fields block &[ ... ]
        if let Some(start) = part.find("&[") {
            if let Some(end) = part[start..].find("],") {
                let block = &part[start..start + end];
                let fields = parse_fields(block);
                if !fields.is_empty() {
                    categories.insert(category_name, fields);
                }
            }
        }
    }
    categories
}

fn parse_fields(block: &str) -> Vec<Field> {
    let mut fields = Vec::new();

    // Simple parsing of DiscoveredField { ... }
    // We assume the formatting is consistent as it's generated code
    let field_blocks: Vec<&str> = block.split("DiscoveredField {").collect();

    for field_str in field_blocks.iter().skip(1) {
        let name = extract_value(field_str, "name: \"", "\"");
        let type_str = extract_value(field_str, "inferred_type: InferredType::", ",");
        let multiple = extract_value(field_str, "appears_multiple: ", ",");
        let freq = extract_value(field_str, "frequency: ", ",");

        if let (Some(n), Some(t), Some(m), Some(f)) = (name, type_str, multiple, freq) {
            fields.push(Field {
                name: n,
                inferred_type: t,
                appears_multiple: m == "true",
                frequency: f.parse().unwrap_or(0),
            });
        }
    }
    fields
}

fn extract_value(source: &str, start_marker: &str, end_marker: &str) -> Option<String> {
    if let Some(start) = source.find(start_marker) {
        let rest = &source[start + start_marker.len()..];
        if let Some(end) = rest.find(end_marker) {
            return Some(rest[..end].trim().to_string());
        }
    }
    None
}

fn generate_struct_code(category: &str, fields: &[Field]) -> String {
    let struct_name = to_pascal_case(category);
    let mut output = String::new();

    // Imports
    output.push_str("use eu4data_derive::{SchemaType, TolerantDeserialize};\n");
    output.push_str("use serde::Serialize;\n\n");

    // Struct
    output.push_str("#[derive(Debug, Clone, Serialize, TolerantDeserialize, SchemaType)]\n");
    output.push_str(&format!("pub struct {} {{\n", struct_name));

    // Dedup fields by sanitized name
    let mut seen_names = HashSet::new();
    let mut sorted_fields: Vec<&Field> = fields.iter().collect();
    sorted_fields.sort_by_key(|f| &f.name);

    for field in sorted_fields {
        let mut sanitized = sanitize_field_name(&field.name);

        // Handle collisions
        while seen_names.contains(&sanitized) {
            sanitized.push('_');
        }
        seen_names.insert(sanitized.clone());

        output.push_str(&format!(
            "    /// Appears in {} entities\n",
            field.frequency
        ));
        if field.inferred_type == "Float" {
            output.push_str("    /// TODO: Consider fixed-point (FixedI32) for simulation layer\n");
        }

        output.push_str(&format!("    #[serde(rename = \"{}\")]\n", field.name));
        let rust_type = map_type(&field.inferred_type, field.appears_multiple);
        output.push_str(&format!("    pub {}: Option<{}>,\n", sanitized, rust_type));
    }

    output.push_str("}\n");
    output
}

fn map_type(inferred: &str, multiple: bool) -> String {
    let base = match inferred {
        "String" => "String",
        "Integer" => "i32", // Assuming i32 for simplicity
        "Float" => "f32",
        "Bool" => "bool",
        "Block" => "serde_json::Value", // Aligned with codegen.rs
        "DynamicBlock" => "std::collections::HashMap<String, serde_json::Value>",
        "IntList" => "Vec<i32>",
        "FloatList" => "Vec<f32>",
        "StringList" => "Vec<String>",
        "Color" => "Vec<f32>", // Safe default
        _ => "serde_json::Value",
    };

    if multiple {
        // If it's already a list type, don't wrap again unless needed?
        // Logic from codegen.rs:
        // if matches!(inferred_type, InferredType::IntList | InferredType::FloatList | InferredType::StringList | InferredType::Color) {
        //     base_type.to_string()
        // } else ... Vec<base>
        if inferred.ends_with("List") || inferred == "Color" {
            base.to_string()
        } else {
            format!("Vec<{}>", base)
        }
    } else {
        base.to_string()
    }
}

fn sanitize_field_name(name: &str) -> String {
    // Basic snake case
    let snake: String = name
        .chars()
        .map(|c| {
            if c.is_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect();

    // Trim/Collapse underscores
    let mut result = String::new();
    let mut last_was_score = true;
    for c in snake.chars() {
        if c == '_' {
            if !last_was_score {
                result.push(c);
            }
            last_was_score = true;
        } else {
            result.push(c);
            last_was_score = false;
        }
    }
    if result.ends_with('_') {
        result.pop();
    }
    if result.is_empty() {
        result = "field".to_string();
    }

    // Keyword escape
    match result.as_str() {
        "as" | "break" | "const" | "continue" | "crate" | "else" | "enum" | "extern" | "false"
        | "fn" | "for" | "if" | "impl" | "in" | "let" | "loop" | "match" | "mod" | "move"
        | "mut" | "pub" | "ref" | "return" | "self" | "Self" | "static" | "struct" | "super"
        | "trait" | "true" | "type" | "unsafe" | "use" | "where" | "while" | "async" | "await"
        | "dyn" | "abstract" | "become" | "box" | "do" | "final" | "macro" | "override"
        | "priv" | "typeof" | "unsized" | "virtual" | "yield" | "try" => format!("r#{}", result),
        _ => result,
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize = true;
    for c in s.chars() {
        if c == '_' {
            capitalize = true;
        } else if capitalize {
            result.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(c);
        }
    }
    result
}

// ============================================================================
// Phase 2: Game Data Manifest Generation
// ============================================================================
//
// Generates a manifest of all game data files with SHA256 hashes at build time.
// This ensures clients can verify they're using compatible game data.
//
// CACHING BEHAVIOR:
// The manifest is only regenerated when:
// - build.rs itself changes
// - EU4_GAME_PATH environment variable changes
// - The generated manifest file is deleted
//
// IMPORTANT: The build script does NOT watch individual game data files.
// If game files change (e.g., EU4 patch), you must manually trigger a rebuild:
//   cargo clean && cargo build
//
// This is intentional to avoid expensive file scanning on every incremental build.
// Watching thousands of game files would slow down all builds significantly.

fn generate_manifest() {
    // Try to get game path using the same cascade as runtime:
    // 1. EU4_GAME_PATH env var
    // 2. Default Steam path for the platform
    let game_path = env::var("EU4_GAME_PATH")
        .ok()
        .map(std::path::PathBuf::from)
        .or_else(|| {
            // Use default Steam paths per platform
            #[cfg(target_os = "windows")]
            {
                Some(std::path::PathBuf::from(
                    "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Europa Universalis IV",
                ))
            }
            #[cfg(target_os = "linux")]
            {
                dirs::home_dir()
                    .map(|home| home.join(".steam/steam/steamapps/common/Europa Universalis IV"))
            }
            #[cfg(target_os = "macos")]
            {
                dirs::home_dir().map(|home| {
                    home.join(
                        "Library/Application Support/Steam/steamapps/common/Europa Universalis IV",
                    )
                })
            }
            #[cfg(not(any(target_os = "windows", target_os = "linux", target_os = "macos")))]
            {
                None
            }
        });

    if let Some(ref path) = game_path {
        if !path.exists() {
            println!(
                "cargo:warning=Game data path does not exist: {}",
                path.display()
            );
            println!("cargo:warning=Manifest will be empty. Set EU4_GAME_PATH to override.");
        } else {
            println!(
                "cargo:warning=Building with game data from: {}",
                path.display()
            );
        }
    } else {
        println!("cargo:warning=Could not determine game data path");
        println!("cargo:warning=Set EU4_GAME_PATH to enable build-time manifest generation");
    }

    // Get git commit hash
    let git_commit = std::process::Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout).ok()
            } else {
                None
            }
        })
        .map(|s| s.trim().to_string());

    if let Some(ref commit) = git_commit {
        println!("cargo:rustc-env=EU4RS_GIT_COMMIT={}", commit);

        // Also watch .git/HEAD and the current ref to ensure re-compilation on new commits
        // but WITHOUT changing the generated source file content.
        println!("cargo:rerun-if-changed=.git/HEAD");
        // Try to find the ref path (e.g. .git/refs/heads/main)
        if let Ok(head_content) = fs::read_to_string(".git/HEAD") {
            if let Some(ref_path) = head_content.strip_prefix("ref: ") {
                let full_ref_path = format!(".git/{}", ref_path.trim());
                println!("cargo:rerun-if-changed={}", full_ref_path);
            }
        }
    }

    // Generate manifest code
    let manifest_code = if let Some(game_path) = game_path {
        generate_manifest_with_data(&game_path)
    } else {
        generate_empty_manifest_code()
    };

    // Write to src/generated/manifest_generated.rs
    let cwd = env::current_dir().unwrap();
    let manifest_dir = cwd.join("src/generated");
    fs::create_dir_all(&manifest_dir).expect("Failed to create generated directory");

    let manifest_path = manifest_dir.join("manifest_generated.rs");

    // Only write if content changed to avoid unnecessary rebuilds
    if let Ok(existing) = fs::read_to_string(&manifest_path) {
        if existing == manifest_code {
            return;
        }
    }

    fs::write(&manifest_path, manifest_code).expect("Failed to write manifest");
}

fn generate_manifest_with_data(game_path: &std::path::Path) -> String {
    use sha2::{Digest, Sha256};
    use walkdir::WalkDir;

    let mut file_hashes = Vec::new();

    // Scan important game data files
    let patterns = [
        ("definition.csv", false),
        ("provinces.bmp", false),
        ("common", true),
        ("history", true),
    ];

    for (pattern, is_dir) in &patterns {
        if *is_dir {
            // Recursive scan for .txt files
            let full_path = game_path.join(pattern);
            if full_path.exists() {
                for entry in WalkDir::new(&full_path)
                    .follow_links(true)
                    .into_iter()
                    .filter_map(|e| e.ok())
                {
                    if entry.file_type().is_file()
                        && entry.path().extension().is_some_and(|ext| ext == "txt")
                    {
                        if let Some(hash) = hash_file(entry.path()) {
                            let rel_path = entry
                                .path()
                                .strip_prefix(game_path)
                                .unwrap()
                                .to_string_lossy()
                                .replace('\\', "/");
                            file_hashes.push((rel_path, hash));
                        }
                    }
                }
            }
        } else {
            // Single file
            let file_path = game_path.join(pattern);
            if file_path.exists() {
                if let Some(hash) = hash_file(&file_path) {
                    file_hashes.push((pattern.to_string(), hash));
                }
            }
        }
    }

    // Sort by path for determinism
    file_hashes.sort_by(|a, b| a.0.cmp(&b.0));

    // Compute combined manifest hash
    let mut hasher = Sha256::new();
    for (path, hash) in &file_hashes {
        hasher.update(path.as_bytes());
        hasher.update(hash);
    }
    let manifest_hash = hasher.finalize();

    // Generate Rust code
    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n\n");

    // File hashes array
    code.push_str("const FILE_HASHES: &[FileHash] = &[\n");
    for (path, hash) in &file_hashes {
        code.push_str(&format!(
            "    FileHash {{ path: \"{}\", sha256: {:?} }},\n",
            path, hash
        ));
    }
    code.push_str("];\n\n");

    // Manifest constant
    code.push_str("pub const GAME_MANIFEST: GameDataManifest = GameDataManifest {\n");
    code.push_str("    sim_version: env!(\"CARGO_PKG_VERSION\"),\n");
    code.push_str("    git_commit: option_env!(\"EU4RS_GIT_COMMIT\"),\n");
    code.push_str("    file_hashes: FILE_HASHES,\n");
    code.push_str(&format!(
        "    manifest_hash: {:?},\n",
        manifest_hash.as_slice()
    ));
    code.push_str("};\n");

    code
}

fn generate_empty_manifest_code() -> String {
    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - NO GAME DATA\n\n");
    code.push_str("pub const GAME_MANIFEST: GameDataManifest = GameDataManifest {\n");
    code.push_str("    sim_version: env!(\"CARGO_PKG_VERSION\"),\n");
    code.push_str("    git_commit: option_env!(\"EU4RS_GIT_COMMIT\"),\n");
    code.push_str("    file_hashes: &[],\n");
    code.push_str("    manifest_hash: [0; 32],\n");
    code.push_str("};\n");

    code
}

fn hash_file(path: &std::path::Path) -> Option<[u8; 32]> {
    use sha2::{Digest, Sha256};

    let contents = fs::read(path).ok()?;
    let mut hasher = Sha256::new();
    hasher.update(&contents);
    let result = hasher.finalize();
    Some(result.into())
}
