//! Build script for eu4data - auto-generates type definitions if missing.
//!
//! This ensures developers don't need to manually run `cargo xtask coverage --generate`
//! before building. The generated types are gitignored but created automatically.

// use std::path::Path;

#![allow(clippy::collapsible_if)]
use std::collections::{HashMap, HashSet};
use std::env;
use std::fs;

fn main() {
    println!("cargo:rerun-if-changed=src/generated/schema.rs");
    println!("cargo:rerun-if-changed=src/generated/categories.rs");
    println!("cargo:rerun-if-changed=src/generated/types"); // Re-run if files are deleted/added
    println!("cargo:rerun-if-changed=build.rs");

    let cwd = env::current_dir().unwrap();
    let schema_path = cwd.join("src/generated/schema.rs");
    let types_dir = cwd.join("src/generated/types");

    // Always ensure output directory exists
    if !types_dir.exists() {
        fs::create_dir_all(&types_dir).expect("Failed to create types directory");
    }

    if !schema_path.exists() {
        println!(
            "cargo:warning=Schema file not found at {:?}. Skipping generation.",
            schema_path
        );
        // Create placeholder mod.rs if missing to allow compilation
        let mod_rs = types_dir.join("mod.rs");
        if !mod_rs.exists() {
            fs::write(&mod_rs, "//! Placeholder\n").unwrap();
        }
        return;
    }

    // Read schema
    let schema_content = fs::read_to_string(&schema_path).expect("Failed to read schema.rs");

    // Parse schema and generate files
    let categories = parse_schema(&schema_content);
    let mut modules: Vec<String> = categories.keys().cloned().collect();
    modules.sort();

    let mut mod_content =
        String::from("// Auto-generated type definitions.\n// Generated by build.rs\n\n");
    for category_name in &modules {
        mod_content.push_str(&format!("pub mod {};\n", category_name.to_lowercase()));
        mod_content.push_str(&format!("pub use {}::*;\n", category_name.to_lowercase()));
    }

    // Generate helper to map DataCategory to fields
    mod_content.push('\n');
    mod_content.push_str("pub fn match_category_fields(category: crate::generated::categories::DataCategory) -> Option<&'static [crate::coverage::FieldInfo]> {\n");
    mod_content.push_str("    use crate::coverage::SchemaFields;\n");
    mod_content.push_str("    match category {\n");

    for category_name in &modules {
        // Category Name: "ImperialReforms" -> Variant: DataCategory::ImperialReforms
        // Module Name: "imperialreforms" -> Struct: ImperialReforms (via to_pascal_case)

        let module_name = category_name.to_lowercase();
        let struct_name = to_pascal_case(category_name);

        mod_content.push_str(&format!(
            "        crate::generated::categories::DataCategory::{} => Some({}::{}::fields()),\n",
            category_name, module_name, struct_name
        ));
    }

    mod_content.push_str("        _ => None,\n");
    mod_content.push_str("    }\n");
    mod_content.push_str("}\n");

    // Write module list to src/generated/types/module_list.rs (intermediate artifact, ignored)
    let module_list_path = types_dir.join("module_list.rs");
    fs::write(&module_list_path, mod_content).unwrap();

    // Write static placeholder mod.rs to src/ (stable, can be committed)
    let static_mod_path = types_dir.join("mod.rs");
    let static_content = "// Stable placeholder. Actual module list is in module_list.rs.\ninclude!(\"module_list.rs\");\n";
    fs::write(static_mod_path, static_content).unwrap();

    // Generate individual files
    for (category, fields) in &categories {
        let code = generate_struct_code(category, fields);
        let path = types_dir.join(format!("{}.rs", category.to_lowercase()));
        fs::write(&path, code).expect("Failed to write generated file");
    }
}

#[derive(Debug)]
struct Field {
    name: String,
    inferred_type: String, // String representation of InferredType enum e.g. "Integer"
    appears_multiple: bool,
    frequency: usize,
}

fn parse_schema(content: &str) -> HashMap<String, Vec<Field>> {
    let mut categories = HashMap::new();

    // Split by category blocks: DataCategory::Name => &[ ... ]
    let category_parts: Vec<&str> = content.split("DataCategory::").collect();

    for part in category_parts.iter().skip(1) {
        // Skip preamble
        let category_name = part.split(" =>").next().unwrap().trim().to_string(); // e.g. Advisortypes or ImperialReforms

        // Find the fields block &[ ... ]
        if let Some(start) = part.find("&[") {
            if let Some(end) = part[start..].find("],") {
                let block = &part[start..start + end];
                let fields = parse_fields(block);
                if !fields.is_empty() {
                    categories.insert(category_name, fields);
                }
            }
        }
    }
    categories
}

fn parse_fields(block: &str) -> Vec<Field> {
    let mut fields = Vec::new();

    // Simple parsing of DiscoveredField { ... }
    // We assume the formatting is consistent as it's generated code
    let field_blocks: Vec<&str> = block.split("DiscoveredField {").collect();

    for field_str in field_blocks.iter().skip(1) {
        let name = extract_value(field_str, "name: \"", "\"");
        let type_str = extract_value(field_str, "inferred_type: InferredType::", ",");
        let multiple = extract_value(field_str, "appears_multiple: ", ",");
        let freq = extract_value(field_str, "frequency: ", ",");

        if let (Some(n), Some(t), Some(m), Some(f)) = (name, type_str, multiple, freq) {
            fields.push(Field {
                name: n,
                inferred_type: t,
                appears_multiple: m == "true",
                frequency: f.parse().unwrap_or(0),
            });
        }
    }
    fields
}

fn extract_value(source: &str, start_marker: &str, end_marker: &str) -> Option<String> {
    if let Some(start) = source.find(start_marker) {
        let rest = &source[start + start_marker.len()..];
        if let Some(end) = rest.find(end_marker) {
            return Some(rest[..end].trim().to_string());
        }
    }
    None
}

fn generate_struct_code(category: &str, fields: &[Field]) -> String {
    let struct_name = to_pascal_case(category);
    let mut output = String::new();

    // Imports
    output.push_str("use eu4data_derive::{SchemaType, TolerantDeserialize};\n");
    output.push_str("use serde::Serialize;\n\n");

    // Struct
    output.push_str("#[derive(Debug, Clone, Serialize, TolerantDeserialize, SchemaType)]\n");
    output.push_str(&format!("pub struct {} {{\n", struct_name));

    // Dedup fields by sanitized name
    let mut seen_names = HashSet::new();
    let mut sorted_fields: Vec<&Field> = fields.iter().collect();
    sorted_fields.sort_by_key(|f| &f.name);

    for field in sorted_fields {
        let mut sanitized = sanitize_field_name(&field.name);

        // Handle collisions
        while seen_names.contains(&sanitized) {
            sanitized.push('_');
        }
        seen_names.insert(sanitized.clone());

        output.push_str(&format!(
            "    /// Appears in {} entities\n",
            field.frequency
        ));
        if field.inferred_type == "Float" {
            output.push_str("    /// TODO: Consider fixed-point (FixedI32) for simulation layer\n");
        }

        output.push_str(&format!("    #[serde(rename = \"{}\")]\n", field.name));
        let rust_type = map_type(&field.inferred_type, field.appears_multiple);
        output.push_str(&format!("    pub {}: Option<{}>,\n", sanitized, rust_type));
    }

    output.push_str("}\n");
    output
}

fn map_type(inferred: &str, multiple: bool) -> String {
    let base = match inferred {
        "String" => "String",
        "Integer" => "i32", // Assuming i32 for simplicity
        "Float" => "f32",
        "Bool" => "bool",
        "Block" => "serde_json::Value", // Aligned with codegen.rs
        "DynamicBlock" => "std::collections::HashMap<String, serde_json::Value>",
        "IntList" => "Vec<i32>",
        "FloatList" => "Vec<f32>",
        "StringList" => "Vec<String>",
        "Color" => "Vec<f32>", // Safe default
        _ => "serde_json::Value",
    };

    if multiple {
        // If it's already a list type, don't wrap again unless needed?
        // Logic from codegen.rs:
        // if matches!(inferred_type, InferredType::IntList | InferredType::FloatList | InferredType::StringList | InferredType::Color) {
        //     base_type.to_string()
        // } else ... Vec<base>
        if inferred.ends_with("List") || inferred == "Color" {
            base.to_string()
        } else {
            format!("Vec<{}>", base)
        }
    } else {
        base.to_string()
    }
}

fn sanitize_field_name(name: &str) -> String {
    // Basic snake case
    let snake: String = name
        .chars()
        .map(|c| {
            if c.is_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect();

    // Trim/Collapse underscores
    let mut result = String::new();
    let mut last_was_score = true;
    for c in snake.chars() {
        if c == '_' {
            if !last_was_score {
                result.push(c);
            }
            last_was_score = true;
        } else {
            result.push(c);
            last_was_score = false;
        }
    }
    if result.ends_with('_') {
        result.pop();
    }
    if result.is_empty() {
        result = "field".to_string();
    }

    // Keyword escape
    match result.as_str() {
        "as" | "break" | "const" | "continue" | "crate" | "else" | "enum" | "extern" | "false"
        | "fn" | "for" | "if" | "impl" | "in" | "let" | "loop" | "match" | "mod" | "move"
        | "mut" | "pub" | "ref" | "return" | "self" | "Self" | "static" | "struct" | "super"
        | "trait" | "true" | "type" | "unsafe" | "use" | "where" | "while" | "async" | "await"
        | "dyn" | "abstract" | "become" | "box" | "do" | "final" | "macro" | "override"
        | "priv" | "typeof" | "unsized" | "virtual" | "yield" | "try" => format!("r#{}", result),
        _ => result,
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize = true;
    for c in s.chars() {
        if c == '_' {
            capitalize = true;
        } else if capitalize {
            result.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(c);
        }
    }
    result
}
