use crate::coverage::DataCategory;
use eu4txt::{DefaultEU4Txt, EU4Txt, EU4TxtAstItem, EU4TxtParseNode};
use rayon::prelude::*;
use std::collections::HashMap;
use std::path::Path;
use std::sync::Mutex;
use walkdir::WalkDir;

#[derive(Debug, Clone)]
pub struct FieldDiscovery {
    pub name: String,
    pub frequency: usize,
    pub sample_value: Option<String>,
}

/// Discovers the schema for a given category by parsing all files in the directory.
pub fn discover_schema(
    eu4_path: &Path,
    category: DataCategory,
) -> Result<HashMap<String, FieldDiscovery>, std::io::Error> {
    let dir_path = eu4_path.join(category.path_suffix());
    if !dir_path.exists() {
        return Ok(HashMap::new());
    }

    let files: Vec<_> = WalkDir::new(dir_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "txt"))
        .collect();

    // Use a thread-safe map for aggregation
    let aggregated_results = Mutex::new(HashMap::new());

    files.par_iter().for_each(|entry| {
        let path = entry.path();
        if let Ok(tokens) = DefaultEU4Txt::open_txt(path.to_str().unwrap_or_default())
            && !tokens.is_empty()
            && let Ok(root_node) = DefaultEU4Txt::parse(tokens)
        {
            let keys = extract_keys_from_ast(&root_node, category);
            let mut map = aggregated_results.lock().unwrap();

            for (key, sample) in keys {
                let entry = map.entry(key.clone()).or_insert(FieldDiscovery {
                    name: key,
                    frequency: 0,
                    sample_value: None,
                });
                entry.frequency += 1;
                if entry.sample_value.is_none() {
                    entry.sample_value = Some(sample);
                }
            }
        }
    });

    Ok(aggregated_results.into_inner().unwrap())
}

/// Generates the content for eu4data/src/generated/schema.rs based on discovered data
pub fn generate_schema_file(eu4_path: &Path) -> Result<String, std::io::Error> {
    let mut output = String::new();
    output.push_str("//! Auto-generated schema definition from game files.\n");
    output.push_str("//! Generated by `cargo xtask coverage --update`\n");
    output.push_str("//! Do not edit manually.\n\n");
    output.push_str("use crate::coverage::DataCategory;\n\n");

    let categories = vec![
        DataCategory::Countries,
        DataCategory::ProvinceHistory,
        DataCategory::TradeGoods,
        DataCategory::Religions,
        DataCategory::Cultures,
    ];

    output.push_str("pub struct DiscoveredField {\n");
    output.push_str("    pub name: &'static str,\n");
    output.push_str("    pub frequency: usize,\n");
    output.push_str("}\n\n");

    output.push_str(
        "pub fn get_discovered_fields(category: DataCategory) -> &'static [DiscoveredField] {\n",
    );
    output.push_str("    match category {\n");

    for cat in categories {
        let fields_map = discover_schema(eu4_path, cat)?;
        let mut fields: Vec<_> = fields_map.values().collect();
        // Sort by frequency desc, then name asc
        fields.sort_by(|a, b| {
            b.frequency
                .cmp(&a.frequency)
                .then_with(|| a.name.cmp(&b.name))
        });

        output.push_str(&format!("        DataCategory::{:?} => &[\n", cat));
        for field in fields {
            // Escape quotes in field names if any (though rare in keys)
            let safe_name = field.name.replace("\"", "\\\"");
            output.push_str(&format!(
                "            DiscoveredField {{ name: \"{}\", frequency: {} }},\n",
                safe_name, field.frequency
            ));
        }
        output.push_str("        ],\n");
    }

    output.push_str("        _ => &[],\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    Ok(output)
}

fn extract_keys_from_ast(root: &EU4TxtParseNode, category: DataCategory) -> Vec<(String, String)> {
    let mut results = Vec::new();

    // Helper to get string representation of a node
    fn node_to_string(node: &EU4TxtParseNode) -> String {
        match &node.entry {
            EU4TxtAstItem::Identifier(s) => s.clone(),
            EU4TxtAstItem::StringValue(s) => format!("\"{}\"", s), // Quote strings
            EU4TxtAstItem::IntValue(i) => i.to_string(),
            EU4TxtAstItem::FloatValue(f) => f.to_string(),
            EU4TxtAstItem::AssignmentList => "{ ... }".to_string(), // Simplified
            _ => "?".to_string(),
        }
    }

    match category {
        // Flat files: keys are at root level
        DataCategory::Countries | DataCategory::ProvinceHistory => {
            for child in &root.children {
                if let EU4TxtAstItem::Assignment = child.entry
                    && let Some(lhs) = child.children.first()
                {
                    let mut key = node_to_string(lhs);
                    // Normalize date keys (e.g., 1444.1.1) to <date>
                    if is_date_key(&key) {
                        key = "<date>".to_string();
                    }
                    // Skip script logic
                    if is_script_logic(&key) {
                        continue;
                    }
                    let val = child
                        .children
                        .get(1)
                        .map(node_to_string)
                        .unwrap_or_default();
                    results.push((key.replace("\"", ""), val));
                }
            }
        }
        // Nested files
        DataCategory::Religions | DataCategory::Cultures | DataCategory::TradeGoods => {
            for child in &root.children {
                if let EU4TxtAstItem::Assignment = child.entry
                    && let Some(rhs) = child.children.get(1)
                    && let EU4TxtAstItem::AssignmentList = rhs.entry
                {
                    // Check if this block contains nested items (the actual definitions)
                    for inner_child in &rhs.children {
                        if let EU4TxtAstItem::Assignment = inner_child.entry
                            && let Some(_) = inner_child.children.first()
                            && let Some(inner_rhs) = inner_child.children.get(1)
                            && let EU4TxtAstItem::AssignmentList = inner_rhs.entry
                        {
                            // We are inside a group, likely looking at a definition
                            for field in &inner_rhs.children {
                                if let EU4TxtAstItem::Assignment = field.entry
                                    && let Some(field_lhs) = field.children.first()
                                {
                                    let mut k = node_to_string(field_lhs);
                                    // Normalize date keys (e.g., 1444.1.1) to <date>
                                    if is_date_key(&k) {
                                        k = "<date>".to_string();
                                    }
                                    // Skip script logic
                                    if is_script_logic(&k) {
                                        continue;
                                    }
                                    let v = field
                                        .children
                                        .get(1)
                                        .map(node_to_string)
                                        .unwrap_or_default();
                                    results.push((k.replace("\"", ""), v));
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }

    results
}

fn is_script_logic(key: &str) -> bool {
    matches!(
        key,
        "OR" | "AND" | "NOT" | "if" | "else" | "else_if" | "limit" | "trigger"
    )
}

fn is_date_key(key: &str) -> bool {
    // Simple heuristic: YYYY.MM.DD
    // Check if it has 2 dots and parts parse as numbers
    let parts: Vec<&str> = key.split('.').collect();
    if parts.len() != 3 {
        return false;
    }
    parts.iter().all(|p| p.parse::<u32>().is_ok())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_date_key_check() {
        assert!(is_date_key("1444.1.1"));
        assert!(is_date_key("1444.11.11"));
        assert!(!is_date_key("owner"));
        assert!(!is_date_key("1444.1"));
    }

    #[test]
    fn test_script_logic_check() {
        assert!(is_script_logic("OR"));
        assert!(is_script_logic("if"));
        assert!(!is_script_logic("owner"));
    }
}
