use eu4txt::{DefaultEU4Txt, EU4Txt, EU4TxtAstItem, EU4TxtParseNode};
use rayon::prelude::*;
use std::collections::HashMap;
use std::path::Path;
use std::sync::Mutex;
use walkdir::WalkDir;

#[derive(Debug, Clone)]
pub struct FieldDiscovery {
    pub name: String,
    pub frequency: usize,
    pub sample_value: Option<String>,
}

/// Discovers the schema for a given path by parsing all files in the directory.
///
/// # Arguments
/// * `eu4_path` - Root EU4 installation path
/// * `path_suffix` - Relative path like "common/religions" or "history/provinces"
/// * `is_nested` - Whether files use nested structure (group -> items)
pub fn discover_schema_at_path(
    eu4_path: &Path,
    path_suffix: &str,
    is_nested: bool,
) -> Result<HashMap<String, FieldDiscovery>, std::io::Error> {
    let dir_path = eu4_path.join(path_suffix);
    if !dir_path.exists() {
        return Ok(HashMap::new());
    }

    let files: Vec<_> = WalkDir::new(dir_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "txt"))
        .collect();

    // Use a thread-safe map for aggregation
    let aggregated_results = Mutex::new(HashMap::new());

    files.par_iter().for_each(|entry| {
        let path = entry.path();
        if let Ok(tokens) = DefaultEU4Txt::open_txt(path.to_str().unwrap_or_default())
            && !tokens.is_empty()
            && let Ok(root_node) = DefaultEU4Txt::parse(tokens)
        {
            let keys = extract_keys_from_ast(&root_node, is_nested);
            let mut map = aggregated_results.lock().unwrap();

            for (key, sample) in keys {
                let entry = map.entry(key.clone()).or_insert(FieldDiscovery {
                    name: key,
                    frequency: 0,
                    sample_value: None,
                });
                entry.frequency += 1;
                if entry.sample_value.is_none() {
                    entry.sample_value = Some(sample);
                }
            }
        }
    });

    Ok(aggregated_results.into_inner().unwrap())
}

/// Generates the content for eu4data/src/generated/schema.rs based on discovered data
pub fn generate_schema_file(eu4_path: &Path) -> Result<String, std::io::Error> {
    let categories = discover_categories(eu4_path)?;

    let mut output = String::new();
    output.push_str("//! Auto-generated schema definition from game files.\n");
    output.push_str("//! Generated by `cargo xtask coverage --update`\n");
    output.push_str("//! Do not edit manually.\n\n");
    output.push_str("use crate::generated::categories::DataCategory;\n\n");

    output.push_str("pub struct DiscoveredField {\n");
    output.push_str("    pub name: &'static str,\n");
    output.push_str("    pub frequency: usize,\n");
    output.push_str("}\n\n");

    output.push_str(
        "pub fn get_discovered_fields(category: DataCategory) -> &'static [DiscoveredField] {\n",
    );
    output.push_str("    match category {\n");

    for cat in &categories {
        let fields_map = discover_schema_at_path(eu4_path, &cat.path_suffix, cat.is_nested)?;
        let mut fields: Vec<_> = fields_map.values().collect();
        // Sort by frequency desc, then name asc
        fields.sort_by(|a, b| {
            b.frequency
                .cmp(&a.frequency)
                .then_with(|| a.name.cmp(&b.name))
        });

        output.push_str(&format!(
            "        DataCategory::{} => &[\n",
            cat.variant_name
        ));
        for field in fields {
            // Escape quotes in field names if any (though rare in keys)
            let safe_name = field.name.replace("\"", "\\\"");
            output.push_str(&format!(
                "            DiscoveredField {{ name: \"{}\", frequency: {} }},\n",
                safe_name, field.frequency
            ));
        }
        output.push_str("        ],\n");
    }

    output.push_str("    }\n");
    output.push_str("}\n");

    Ok(output)
}

/// Discovered category info for code generation.
#[derive(Debug, Clone)]
pub struct DiscoveredCategory {
    /// Enum variant name (PascalCase), e.g., "TradeGoods"
    pub variant_name: String,
    /// Display name, e.g., "Trade Goods"
    pub display_name: String,
    /// Path suffix relative to EU4 root, e.g., "common/tradegoods"
    pub path_suffix: String,
    /// Whether this is a "nested" file structure (groups containing items)
    pub is_nested: bool,
}

/// Discovers all data categories by scanning common/ and history/ subdirectories.
pub fn discover_categories(eu4_path: &Path) -> Result<Vec<DiscoveredCategory>, std::io::Error> {
    let mut categories = Vec::new();

    // Scan common/ subdirectories
    let common_dir = eu4_path.join("common");
    if common_dir.exists() {
        for entry in std::fs::read_dir(&common_dir)? {
            let entry = entry?;
            if entry.file_type()?.is_dir() {
                let folder_name = entry.file_name().to_string_lossy().to_string();
                let variant_name = folder_to_variant(&folder_name);
                let display_name = folder_to_display(&folder_name);
                let path_suffix = format!("common/{}", folder_name);

                // Heuristic: most common/ folders are nested (group -> items)
                // Exception: countries/ is flat
                let is_nested = folder_name != "countries";

                categories.push(DiscoveredCategory {
                    variant_name,
                    display_name,
                    path_suffix,
                    is_nested,
                });
            }
        }
    }

    // Scan history/ subdirectories (these are typically flat)
    let history_dir = eu4_path.join("history");
    if history_dir.exists() {
        for entry in std::fs::read_dir(&history_dir)? {
            let entry = entry?;
            if entry.file_type()?.is_dir() {
                let folder_name = entry.file_name().to_string_lossy().to_string();
                // Prefix with "History" to avoid collisions (e.g., history/countries vs common/countries)
                let variant_name = format!("History{}", folder_to_variant(&folder_name));
                let display_name = format!("{} History", folder_to_display(&folder_name));
                let path_suffix = format!("history/{}", folder_name);

                categories.push(DiscoveredCategory {
                    variant_name,
                    display_name,
                    path_suffix,
                    is_nested: false, // history files are typically flat
                });
            }
        }
    }

    // Sort by variant name for stable output
    categories.sort_by(|a, b| a.variant_name.cmp(&b.variant_name));

    Ok(categories)
}

/// Generates the content for eu4data/src/generated/categories.rs
pub fn generate_categories_file(eu4_path: &Path) -> Result<String, std::io::Error> {
    let categories = discover_categories(eu4_path)?;

    let mut output = String::new();
    output.push_str("//! Auto-generated category definitions from game files.\n");
    output.push_str("//! Generated by `cargo xtask coverage --update`\n");
    output.push_str("//! Do not edit manually.\n\n");

    // Generate the enum
    output.push_str(
        "/// Categories of EU4 game data, discovered from common/ and history/ subdirectories.\n",
    );
    output.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    output.push_str("pub enum DataCategory {\n");
    for cat in &categories {
        output.push_str(&format!("    {},\n", cat.variant_name));
    }
    output.push_str("}\n\n");

    // Generate as_str()
    output.push_str("impl DataCategory {\n");
    output.push_str("    pub fn as_str(&self) -> &'static str {\n");
    output.push_str("        match self {\n");
    for cat in &categories {
        output.push_str(&format!(
            "            DataCategory::{} => \"{}\",\n",
            cat.variant_name, cat.display_name
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // Generate path_suffix()
    output.push_str("    pub fn path_suffix(&self) -> &'static str {\n");
    output.push_str("        match self {\n");
    for cat in &categories {
        output.push_str(&format!(
            "            DataCategory::{} => \"{}\",\n",
            cat.variant_name, cat.path_suffix
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // Generate is_nested()
    output.push_str(
        "    /// Returns true if this category uses nested file structure (group -> items).\n",
    );
    output.push_str("    pub fn is_nested(&self) -> bool {\n");
    output.push_str("        match self {\n");
    for cat in &categories {
        output.push_str(&format!(
            "            DataCategory::{} => {},\n",
            cat.variant_name, cat.is_nested
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n\n");

    // Generate ALL_CATEGORIES constant
    output.push_str("/// All discovered categories (for iteration).\n");
    output.push_str("pub const ALL_CATEGORIES: &[DataCategory] = &[\n");
    for cat in &categories {
        output.push_str(&format!("    DataCategory::{},\n", cat.variant_name));
    }
    output.push_str("];\n");

    Ok(output)
}

/// Converts a folder name to a PascalCase enum variant name.
/// e.g., "trade_goods" -> "TradeGoods", "countries" -> "Countries"
fn folder_to_variant(folder: &str) -> String {
    folder
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

/// Converts a folder name to a display name.
/// e.g., "trade_goods" -> "Trade Goods", "countries" -> "Countries"
fn folder_to_display(folder: &str) -> String {
    folder
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn extract_keys_from_ast(root: &EU4TxtParseNode, is_nested: bool) -> Vec<(String, String)> {
    let mut results = Vec::new();

    // Helper to get string representation of a node
    fn node_to_string(node: &EU4TxtParseNode) -> String {
        match &node.entry {
            EU4TxtAstItem::Identifier(s) => s.clone(),
            EU4TxtAstItem::StringValue(s) => format!("\"{}\"", s), // Quote strings
            EU4TxtAstItem::IntValue(i) => i.to_string(),
            EU4TxtAstItem::FloatValue(f) => f.to_string(),
            EU4TxtAstItem::AssignmentList => "{ ... }".to_string(), // Simplified
            _ => "?".to_string(),
        }
    }

    if is_nested {
        // Nested files: groups containing items (e.g., religions, cultures, trade goods)
        for child in &root.children {
            if let EU4TxtAstItem::Assignment = child.entry
                && let Some(rhs) = child.children.get(1)
                && let EU4TxtAstItem::AssignmentList = rhs.entry
            {
                // Check if this block contains nested items (the actual definitions)
                for inner_child in &rhs.children {
                    if let EU4TxtAstItem::Assignment = inner_child.entry
                        && let Some(_) = inner_child.children.first()
                        && let Some(inner_rhs) = inner_child.children.get(1)
                        && let EU4TxtAstItem::AssignmentList = inner_rhs.entry
                    {
                        // We are inside a group, likely looking at a definition
                        for field in &inner_rhs.children {
                            if let EU4TxtAstItem::Assignment = field.entry
                                && let Some(field_lhs) = field.children.first()
                            {
                                let mut k = node_to_string(field_lhs);
                                // Normalize date keys (e.g., 1444.1.1) to <date>
                                if is_date_key(&k) {
                                    k = "<date>".to_string();
                                }
                                // Skip script logic
                                if is_script_logic(&k) {
                                    continue;
                                }
                                let v = field
                                    .children
                                    .get(1)
                                    .map(node_to_string)
                                    .unwrap_or_default();
                                results.push((k.replace("\"", ""), v));
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Flat files: keys are at root level (e.g., countries, province history)
        for child in &root.children {
            if let EU4TxtAstItem::Assignment = child.entry
                && let Some(lhs) = child.children.first()
            {
                let mut key = node_to_string(lhs);
                // Normalize date keys (e.g., 1444.1.1) to <date>
                if is_date_key(&key) {
                    key = "<date>".to_string();
                }
                // Skip script logic
                if is_script_logic(&key) {
                    continue;
                }
                let val = child
                    .children
                    .get(1)
                    .map(node_to_string)
                    .unwrap_or_default();
                results.push((key.replace("\"", ""), val));
            }
        }
    }

    results
}

fn is_script_logic(key: &str) -> bool {
    matches!(
        key,
        "OR" | "AND" | "NOT" | "if" | "else" | "else_if" | "limit" | "trigger"
    )
}

fn is_date_key(key: &str) -> bool {
    // Simple heuristic: YYYY.MM.DD
    // Check if it has 2 dots and parts parse as numbers
    let parts: Vec<&str> = key.split('.').collect();
    if parts.len() != 3 {
        return false;
    }
    parts.iter().all(|p| p.parse::<u32>().is_ok())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_date_key_check() {
        assert!(is_date_key("1444.1.1"));
        assert!(is_date_key("1444.11.11"));
        assert!(!is_date_key("owner"));
        assert!(!is_date_key("1444.1"));
    }

    #[test]
    fn test_script_logic_check() {
        assert!(is_script_logic("OR"));
        assert!(is_script_logic("if"));
        assert!(!is_script_logic("owner"));
    }
}
