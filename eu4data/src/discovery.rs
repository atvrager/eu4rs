use eu4txt::{DefaultEU4Txt, EU4Txt, EU4TxtAstItem, EU4TxtParseNode};
use rayon::prelude::*;
use std::collections::HashMap;
use std::path::Path;
use std::sync::Mutex;
use walkdir::WalkDir;

/// Inferred Rust type from EU4 data values.
/// See docs/type_system.md for the design rationale (determinism, SIMD, forward compatibility).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InferredType {
    /// Integer number (e.g., 1, 100, -5). Exact, SIMD-friendly.
    Integer,
    /// Floating point number (e.g., 0.1, 100.5). May need fixed-point for sim layer.
    Float,
    /// String value (e.g., "text" or unquoted identifier)
    String,
    /// Boolean (yes/no)
    Bool,
    /// List of integers (e.g., { 1 2 3 })
    IntList,
    /// List of floats (e.g., { 0.1 0.2 })
    FloatList,
    /// List of strings (e.g., { "a" "b" })
    StringList,
    /// Nested block with known structure (e.g., { key = value })
    Block,
    /// Dynamic block with variable keys (e.g., { modifier_name = 0.1 })
    DynamicBlock,
    /// Cannot infer type - flag for human review
    Unknown,
}

/// Enhanced field discovery with type inference.
#[derive(Debug, Clone)]
pub struct EnhancedFieldDiscovery {
    pub name: String,
    pub frequency: usize,
    pub inferred_type: InferredType,
    pub appears_multiple: bool,
    pub sample_values: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct FieldDiscovery {
    pub name: String,
    pub frequency: usize,
    pub sample_value: Option<String>,
    pub appears_multiple: bool,
}

/// Discovers the schema for a given path by parsing all files in the directory.
///
/// # Arguments
/// * `eu4_path` - Root EU4 installation path
/// * `path_suffix` - Relative path like "common/religions" or "history/provinces"
/// * `is_nested` - Whether files use nested structure (group -> items)
pub fn discover_schema_at_path(
    eu4_path: &Path,
    path_suffix: &str,
    is_nested: bool,
) -> Result<HashMap<String, FieldDiscovery>, std::io::Error> {
    let dir_path = eu4_path.join(path_suffix);
    if !dir_path.exists() {
        return Ok(HashMap::new());
    }

    let files: Vec<_> = WalkDir::new(dir_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "txt"))
        .collect();

    // Use a thread-safe map for aggregation
    let aggregated_results = Mutex::new(HashMap::new());

    files.par_iter().for_each(|entry| {
        let path = entry.path();
        if let Ok(tokens) = DefaultEU4Txt::open_txt(path.to_str().unwrap_or_default())
            && !tokens.is_empty()
            && let Ok(root_node) = DefaultEU4Txt::parse(tokens)
        {
            let keys = extract_keys_from_ast(&root_node, is_nested);
            let mut map = aggregated_results.lock().unwrap();
            let mut seen_in_this_file = std::collections::HashSet::new();

            for (key, sample) in keys {
                let entry = map.entry(key.clone()).or_insert(FieldDiscovery {
                    name: key.clone(),
                    frequency: 0,
                    sample_value: None,
                    appears_multiple: false,
                });
                entry.frequency += 1;
                if entry.sample_value.is_none() {
                    entry.sample_value = Some(sample);
                }
                if seen_in_this_file.contains(&key) {
                    entry.appears_multiple = true;
                }
                seen_in_this_file.insert(key);
            }
        }
    });

    Ok(aggregated_results.into_inner().unwrap())
}

/// Generates the content for eu4data/src/generated/schema.rs based on discovered data
pub fn generate_schema_file(eu4_path: &Path) -> Result<String, std::io::Error> {
    let categories = discover_categories(eu4_path)?;

    let mut output = String::new();
    output.push_str("//! Auto-generated schema definition from game files.\n");
    output.push_str("//! Generated by `cargo xtask coverage --update`\n");
    output.push_str("//! Do not edit manually.\n\n");
    output.push_str("use crate::generated::categories::DataCategory;\n");
    output.push_str("use crate::discovery::InferredType;\n\n");

    output.push_str("pub struct DiscoveredField {\n");
    output.push_str("    pub name: &'static str,\n");
    output.push_str("    pub frequency: usize,\n");
    output.push_str("    pub inferred_type: InferredType,\n");
    output.push_str("    pub appears_multiple: bool,\n");
    output.push_str("}\n\n");

    output.push_str(
        "pub fn get_discovered_fields(category: DataCategory) -> &'static [DiscoveredField] {\n",
    );
    output.push_str("    match category {\n");

    for cat in &categories {
        let fields_map = discover_schema_at_path(eu4_path, &cat.path_suffix, cat.is_nested)?;
        let mut fields: Vec<_> = fields_map.values().collect();
        // Sort by frequency desc, then name asc
        fields.sort_by(|a, b| {
            b.frequency
                .cmp(&a.frequency)
                .then_with(|| a.name.cmp(&b.name))
        });

        output.push_str(&format!(
            "        DataCategory::{} => &[\n",
            cat.variant_name
        ));
        for field in fields {
            // Escape quotes in field names if any (though rare in keys)
            let safe_name = field.name.replace("\"", "\\\"");
            // Infer type from sample value
            let inferred_type = field
                .sample_value
                .as_ref()
                .map(|v| infer_type(v))
                .unwrap_or(InferredType::Unknown);
            output.push_str(&format!(
                "            DiscoveredField {{ name: \"{}\", frequency: {}, inferred_type: InferredType::{:?}, appears_multiple: {} }},\n",
                safe_name, field.frequency, inferred_type, field.appears_multiple
            ));
        }
        output.push_str("        ],\n");
    }

    output.push_str("    }\n");
    output.push_str("}\n");

    Ok(output)
}

/// Discovered category info for code generation.
#[derive(Debug, Clone)]
pub struct DiscoveredCategory {
    /// Enum variant name (PascalCase), e.g., "TradeGoods"
    pub variant_name: String,
    /// Display name, e.g., "Trade Goods"
    pub display_name: String,
    /// Path suffix relative to EU4 root, e.g., "common/tradegoods"
    pub path_suffix: String,
    /// Whether this is a "nested" file structure (groups containing items)
    pub is_nested: bool,
}

/// Discovers all data categories by scanning common/ and history/ subdirectories.
pub fn discover_categories(eu4_path: &Path) -> Result<Vec<DiscoveredCategory>, std::io::Error> {
    let mut categories = Vec::new();

    // Categories to skip entirely (not useful for simulation)
    // - countries: Contains ruler name weights like "'Abbas #0 = 1", not schema data
    //   This produces a 42k line struct that causes stack overflow in compilation.
    const EXCLUDED_CATEGORIES: &[&str] = &["countries"];

    // Scan common/ subdirectories
    let common_dir = eu4_path.join("common");
    if common_dir.exists() {
        for entry in std::fs::read_dir(&common_dir)? {
            let entry = entry?;
            if entry.file_type()?.is_dir() {
                let folder_name = entry.file_name().to_string_lossy().to_string();

                // Skip excluded categories
                if EXCLUDED_CATEGORIES.contains(&folder_name.as_str()) {
                    continue;
                }
                let variant_name = folder_to_variant(&folder_name);
                let display_name = folder_to_display(&folder_name);
                let path_suffix = format!("common/{}", folder_name);

                // Heuristic: most common/ folders are nested (group -> items)
                // Exceptions: folders where items are directly at root level
                // Note: "countries" is in EXCLUDED_CATEGORIES, so not listed here
                let is_nested = !matches!(folder_name.as_str(), "buildings" | "prices" | "units");

                categories.push(DiscoveredCategory {
                    variant_name,
                    display_name,
                    path_suffix,
                    is_nested,
                });
            }
        }
    }

    // Scan history/ subdirectories (these are typically flat)
    let history_dir = eu4_path.join("history");
    if history_dir.exists() {
        for entry in std::fs::read_dir(&history_dir)? {
            let entry = entry?;
            if entry.file_type()?.is_dir() {
                let folder_name = entry.file_name().to_string_lossy().to_string();
                // Prefix with "History" to avoid collisions (e.g., history/countries vs common/countries)
                let variant_name = format!("History{}", folder_to_variant(&folder_name));
                let display_name = format!("{} History", folder_to_display(&folder_name));
                let path_suffix = format!("history/{}", folder_name);

                categories.push(DiscoveredCategory {
                    variant_name,
                    display_name,
                    path_suffix,
                    is_nested: false, // history files are typically flat
                });
            }
        }
    }

    // Sort by variant name for stable output
    categories.sort_by(|a, b| a.variant_name.cmp(&b.variant_name));

    Ok(categories)
}

/// Generates the content for eu4data/src/generated/categories.rs
pub fn generate_categories_file(eu4_path: &Path) -> Result<String, std::io::Error> {
    let categories = discover_categories(eu4_path)?;

    let mut output = String::new();
    output.push_str("//! Auto-generated category definitions from game files.\n");
    output.push_str("//! Generated by `cargo xtask coverage --update`\n");
    output.push_str("//! Do not edit manually.\n\n");

    // Generate the enum
    output.push_str(
        "/// Categories of EU4 game data, discovered from common/ and history/ subdirectories.\n",
    );
    output.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    output.push_str("pub enum DataCategory {\n");
    for cat in &categories {
        output.push_str(&format!("    {},\n", cat.variant_name));
    }
    output.push_str("}\n\n");

    // Generate as_str()
    output.push_str("impl DataCategory {\n");
    output.push_str("    pub fn as_str(&self) -> &'static str {\n");
    output.push_str("        match self {\n");
    for cat in &categories {
        output.push_str(&format!(
            "            DataCategory::{} => \"{}\",\n",
            cat.variant_name, cat.display_name
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // Generate path_suffix()
    output.push_str("    pub fn path_suffix(&self) -> &'static str {\n");
    output.push_str("        match self {\n");
    for cat in &categories {
        output.push_str(&format!(
            "            DataCategory::{} => \"{}\",\n",
            cat.variant_name, cat.path_suffix
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // Generate is_nested()
    output.push_str(
        "    /// Returns true if this category uses nested file structure (group -> items).\n",
    );
    output.push_str("    pub fn is_nested(&self) -> bool {\n");
    output.push_str("        match self {\n");
    for cat in &categories {
        output.push_str(&format!(
            "            DataCategory::{} => {},\n",
            cat.variant_name, cat.is_nested
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n\n");

    // Generate ALL_CATEGORIES constant
    output.push_str("/// All discovered categories (for iteration).\n");
    output.push_str("pub const ALL_CATEGORIES: &[DataCategory] = &[\n");
    for cat in &categories {
        output.push_str(&format!("    DataCategory::{},\n", cat.variant_name));
    }
    output.push_str("];\n");

    Ok(output)
}

/// Converts a folder name to a PascalCase enum variant name.
/// e.g., "trade_goods" -> "TradeGoods", "countries" -> "Countries"
fn folder_to_variant(folder: &str) -> String {
    folder
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

/// Converts a folder name to a display name.
/// e.g., "trade_goods" -> "Trade Goods", "countries" -> "Countries"
fn folder_to_display(folder: &str) -> String {
    folder
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn extract_keys_from_ast(root: &EU4TxtParseNode, is_nested: bool) -> Vec<(String, String)> {
    let mut results = Vec::new();

    // Helper to get string representation of a node
    fn node_to_string(node: &EU4TxtParseNode) -> String {
        match &node.entry {
            EU4TxtAstItem::Identifier(s) => s.clone(),
            EU4TxtAstItem::StringValue(s) => format!("\"{}\"", s), // Quote strings
            EU4TxtAstItem::IntValue(i) => i.to_string(),
            EU4TxtAstItem::FloatValue(f) => f.to_string(),
            EU4TxtAstItem::AssignmentList => {
                let content: Vec<String> = node
                    .children
                    .iter()
                    .take(4) // Sample first 4 items
                    .map(node_to_string)
                    .collect();
                let s = content.join(" ");
                if node.children.len() > 4 {
                    format!("{{ {} ... }}", s)
                } else {
                    format!("{{ {} }}", s)
                }
            }
            EU4TxtAstItem::Assignment => {
                if let (Some(lhs), Some(rhs)) = (node.children.first(), node.children.get(1)) {
                    format!("{}={}", node_to_string(lhs), node_to_string(rhs))
                } else {
                    "?".to_string()
                }
            }
            _ => "?".to_string(),
        }
    }

    if is_nested {
        // Nested files: groups containing items (e.g., religions, cultures, trade goods)
        for child in &root.children {
            if let EU4TxtAstItem::Assignment = child.entry
                && let Some(rhs) = child.children.get(1)
                && let EU4TxtAstItem::AssignmentList = rhs.entry
            {
                // Check if this block contains nested items (the actual definitions)
                for inner_child in &rhs.children {
                    if let EU4TxtAstItem::Assignment = inner_child.entry
                        && let Some(_) = inner_child.children.first()
                        && let Some(inner_rhs) = inner_child.children.get(1)
                        && let EU4TxtAstItem::AssignmentList = inner_rhs.entry
                    {
                        // We are inside a group, likely looking at a definition
                        for field in &inner_rhs.children {
                            if let EU4TxtAstItem::Assignment = field.entry
                                && let Some(field_lhs) = field.children.first()
                            {
                                let mut k = node_to_string(field_lhs);
                                // Normalize date keys (e.g., 1444.1.1) to <date>
                                if is_date_key(&k) {
                                    k = "<date>".to_string();
                                }
                                // Skip script logic
                                if is_script_logic(&k) {
                                    continue;
                                }
                                let v = field
                                    .children
                                    .get(1)
                                    .map(node_to_string)
                                    .unwrap_or_default();
                                results.push((k.replace("\"", ""), v));
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Flat files: keys are at root level (e.g., countries, province history)
        // For files like buildings where each top-level key has a block value,
        // we extract fields from INSIDE those blocks (cost, time, modifier, etc.)
        for child in &root.children {
            if let EU4TxtAstItem::Assignment = child.entry
                && let Some(lhs) = child.children.first()
                && let Some(rhs) = child.children.get(1)
            {
                let key = node_to_string(lhs);
                // Skip script logic at top level
                if is_script_logic(&key) {
                    continue;
                }

                // If the RHS is a block, extract fields from inside it
                // This handles structures like: building_name = { cost = 100 time = 12 }
                if let EU4TxtAstItem::AssignmentList = rhs.entry {
                    for field in &rhs.children {
                        if let EU4TxtAstItem::Assignment = field.entry
                            && let Some(field_lhs) = field.children.first()
                        {
                            let mut field_key = node_to_string(field_lhs);
                            if is_date_key(&field_key) {
                                field_key = "<date>".to_string();
                            }
                            if is_script_logic(&field_key) {
                                continue;
                            }
                            let field_val = field
                                .children
                                .get(1)
                                .map(node_to_string)
                                .unwrap_or_default();
                            results.push((field_key.replace("\"", ""), field_val));
                        }
                    }
                } else {
                    // Simple key = value at root level
                    let mut key = key;
                    if is_date_key(&key) {
                        key = "<date>".to_string();
                    }
                    let val = node_to_string(rhs);
                    results.push((key.replace("\"", ""), val));
                }
            }
        }
    }

    results
}

fn is_script_logic(key: &str) -> bool {
    matches!(
        key,
        "OR" | "AND" | "NOT" | "if" | "else" | "else_if" | "limit" | "trigger"
    )
}

fn is_date_key(key: &str) -> bool {
    // Simple heuristic: YYYY.MM.DD
    // Check if it has 2 dots and parts parse as numbers
    let parts: Vec<&str> = key.split('.').collect();
    if parts.len() != 3 {
        return false;
    }
    parts.iter().all(|p| p.parse::<u32>().is_ok())
}

/// Infers the type of a field based on its string value.
/// See docs/type_system.md for why we distinguish integers from floats.
pub fn infer_type(value: &str) -> InferredType {
    let v = value.trim();

    if v == "yes" || v == "no" {
        return InferredType::Bool;
    }

    if v.starts_with('"') && v.ends_with('"') {
        return InferredType::String;
    }

    // Check integer BEFORE float (integers are SIMD-friendly and exact)
    if v.parse::<i32>().is_ok() {
        return InferredType::Integer;
    }

    // Floats have decimals - may need fixed-point conversion for simulation layer
    if v.parse::<f32>().is_ok() {
        return InferredType::Float;
    }

    if v.starts_with('{') && v.ends_with('}') {
        return infer_block_type(v);
    }

    // Default to String for unquoted identifiers
    InferredType::String
}

/// Analyzes a block content { ... } to determine if it's a list or a structured block.
fn infer_block_type(block: &str) -> InferredType {
    let content = block[1..block.len() - 1].trim();
    if content.is_empty() {
        return InferredType::Unknown; // Empty block
    }

    // Heuristic: If it contains '=', it's likely a struct/map (Block or DynamicBlock)
    // This assumes the AST toString implementation preserves '=' for assignments.
    // Our node_to_string simplifies "{ ... }", so we might need real samples here.
    // Assuming we get raw-ish string or simplified representation:

    // Note: The current `node_to_string` implementation in `extract_keys_from_ast` returns "{ ... }"
    // for AssignmentList. This function logic assumes we eventually pass better sample values.
    // For now, if we see '=', treat as Block.
    if content.contains('=') {
        // TODO: Distinguish between Block (known keys) and DynamicBlock (variable keys)
        // This likely requires analyzing multiple samples or looking at keys.
        // For now, default to Block.
        return InferredType::Block;
    }

    // Usage of splitting by whitespace to check for list elements
    let parts: Vec<&str> = content.split_whitespace().collect();

    let mut all_floats = true;
    let mut all_ints = true;

    for part in &parts {
        if part.parse::<i64>().is_err() {
            all_ints = false;
        }
        if part.parse::<f32>().is_err() {
            all_floats = false;
        }
    }

    if all_ints {
        return InferredType::IntList;
    }
    if all_floats {
        return InferredType::FloatList;
    }

    // If not numbers, assume strings
    InferredType::StringList
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_date_key_check() {
        assert!(is_date_key("1444.1.1"));
        assert!(is_date_key("1444.11.11"));
        assert!(!is_date_key("owner"));
        assert!(!is_date_key("1444.1"));
    }

    #[test]
    fn test_script_logic_check() {
        assert!(is_script_logic("OR"));
        assert!(is_script_logic("if"));
        assert!(!is_script_logic("owner"));
    }

    #[test]
    fn test_type_inference() {
        assert_eq!(infer_type("yes"), InferredType::Bool);
        assert_eq!(infer_type("no"), InferredType::Bool);
        assert_eq!(infer_type("0.123"), InferredType::Float);
        assert_eq!(infer_type("10"), InferredType::Integer); // Integers are exact, SIMD-friendly
        assert_eq!(infer_type("-5"), InferredType::Integer);
        assert_eq!(infer_type("\"hello\""), InferredType::String);
        assert_eq!(infer_type("plain_text"), InferredType::String);

        // List tests
        assert_eq!(infer_type("{ 1 2 3 }"), InferredType::IntList);
        assert_eq!(infer_type("{ 1.0 2.5 }"), InferredType::FloatList);
        assert_eq!(infer_type("{ a b c }"), InferredType::StringList);
        assert_eq!(infer_type("{ \"a\" \"b\" }"), InferredType::StringList);

        // Block tests (primitive heuristic)
        assert_eq!(infer_type("{ a = 1 }"), InferredType::Block);
    }
}
