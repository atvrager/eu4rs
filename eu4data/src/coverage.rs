use std::collections::HashMap;
use std::path::Path;

// DataCategory is now generated from game files
pub use crate::generated::categories::{ALL_CATEGORIES, DataCategory};

// Re-export the derive macro for convenience
pub use eu4data_derive::SchemaType;

/// Field metadata generated by the SchemaType derive macro.
/// This is what the proc-macro outputs for each field.
#[derive(Debug, Clone, Copy)]
pub struct FieldInfo {
    pub name: &'static str,
    pub visualized: bool, // Used for map rendering
    pub simulated: bool,  // Used for game simulation
}

/// Trait implemented by structs with `#[derive(SchemaType)]`.
pub trait SchemaFields {
    fn fields() -> &'static [FieldInfo];
}

/// Coverage status for a single field within a struct
#[derive(Debug, Clone)]
pub struct FieldCoverage {
    pub name: &'static str,
    pub parsed: bool,                // Do we have this in our struct?
    pub visualized: bool,            // Used for map rendering?
    pub simulated: bool,             // Used for game simulation?
    pub notes: Option<&'static str>, // Why is it missing/unused?
}

/// Coverage status for an entire data category
#[derive(Debug)]
pub struct CategoryCoverage {
    pub category: DataCategory,
    pub game_files: usize,        // Files found in EU4 install
    pub parsed_files: usize,      // Files we successfully parse
    pub total_fields: usize,      // Estimated total distinct fields in this category
    pub our_fields: usize,        // Fields we define in structs
    pub visualized_fields: usize, // Fields used for map rendering
    pub simulated_fields: usize,  // Fields used for game simulation
    pub details: Vec<FieldCoverage>,
    pub discovered_fields: Option<HashMap<String, crate::discovery::FieldDiscovery>>,
}

/// The complete coverage report
pub struct CoverageReport {
    pub categories: Vec<CategoryCoverage>,
    pub timestamp: String,
}

impl CoverageReport {
    pub fn to_terminal(&self) -> String {
        let mut output = String::new();
        output.push_str("üìä EU4 Data Coverage Report\n");
        output.push_str("==========================\n\n");

        for cat in &self.categories {
            let total = cat.total_fields as f64;
            let parsed_pct = if total > 0.0 {
                (cat.our_fields as f64 / total) * 100.0
            } else {
                0.0
            };
            let vis_pct = if total > 0.0 {
                (cat.visualized_fields as f64 / total) * 100.0
            } else {
                0.0
            };
            let sim_pct = if total > 0.0 {
                (cat.simulated_fields as f64 / total) * 100.0
            } else {
                0.0
            };

            let bar_len = 20;
            let filled_len = (parsed_pct / 100.0 * bar_len as f64).round() as usize;
            let bar: String = "‚ñà".repeat(filled_len) + &"‚ñë".repeat(bar_len - filled_len);

            output.push_str(&format!(
                "{:<32} {}  P:{:>5.1}%  V:{:>5.1}%  S:{:>5.1}%\n",
                cat.category.as_str(),
                bar,
                parsed_pct,
                vis_pct,
                sim_pct
            ));

            if let Some(discovered) = &cat.discovered_fields {
                output.push_str(&format!(
                    "    üîé Discovered {} unique fields\n",
                    discovered.len()
                ));
                // Show top 5 most frequent fields
                let mut fields: Vec<_> = discovered.values().collect();
                fields.sort_by_key(|f| std::cmp::Reverse(f.frequency));

                for f in fields.iter().take(5) {
                    let status = if cat.details.iter().any(|d| d.name == f.name && d.parsed) {
                        "‚úÖ"
                    } else {
                        "‚ùå"
                    };
                    output.push_str(&format!(
                        "      - {} {:<25} (freq: {})\n",
                        status, f.name, f.frequency
                    ));
                }
                if fields.len() > 5 {
                    output.push_str("      ...\n");
                }
                output.push('\n');
            }
        }

        output
    }
}

/// Generates the static "Supported Fields" documentation.
/// This depends ONLY on the code definitions, not on any game files.
pub fn generate_static_docs() -> String {
    let mut output = String::new();
    output.push_str("# EU4 Data Support Matrix\n\n");
    output.push_str("This document is auto-generated from `eu4data/src/coverage.rs`. **Do not edit manually.**\n");
    output.push_str(
        "It defines which EU4 data fields are currently parsed and used by `eu4rs` project.\n\n",
    );

    let registry = get_gold_standard_registry();
    let mut categories: Vec<_> = registry.keys().collect();
    categories.sort_by_key(|c| c.as_str());

    for cat in categories {
        // Summary for category
        let fields = &registry[cat];
        let total = fields.len();
        let parsed = fields.iter().filter(|f| f.parsed).count();
        let visualized = fields.iter().filter(|f| f.visualized).count();

        output.push_str(&format!("## {}\n\n", cat.as_str()));
        output.push_str(&format!("- **Total Known Fields:** {}\n", total));
        output.push_str(&format!(
            "- **Parsed:** {} ({:.1}%)\n",
            parsed,
            (parsed as f64 / total as f64) * 100.0
        ));
        output.push_str(&format!(
            "- **Visualized:** {} ({:.1}%)\n\n",
            visualized,
            (visualized as f64 / total as f64) * 100.0
        ));

        output.push_str("| Field | Parsed | Visualized | Simulated | Notes |\n");
        output.push_str("|-------|--------|------------|-----------|-------|\n");

        for field in fields {
            output.push_str(&format!(
                "| `{}` | {} | {} | {} | {} |\n",
                field.name,
                if field.parsed { "‚úÖ" } else { "‚ùå" },
                if field.visualized { "‚úÖ" } else { "-" },
                if field.simulated { "‚úÖ" } else { "-" },
                field.notes.unwrap_or("")
            ));
        }
        output.push('\n');
    }

    output
}

/// Returns the registry of fields for each category, combining empirical discovery with manual annotations.
pub fn get_gold_standard_registry() -> HashMap<DataCategory, Vec<FieldCoverage>> {
    let mut registry = HashMap::new();

    for &cat in ALL_CATEGORIES {
        let discovered = crate::generated::schema::get_discovered_fields(cat);
        let manual_annotations = get_manual_annotations(cat);
        let mut fields = Vec::new();

        // Check if we have a catch-all marker ("*")
        let has_catch_all = manual_annotations.iter().any(|(k, _)| *k == "*");

        // 1. Add all discovered fields

        for d in discovered {
            let annotation = manual_annotations.get(d.name);
            fields.push(FieldCoverage {
                name: d.name,
                parsed: annotation.map(|a| a.parsed).unwrap_or(has_catch_all),
                visualized: annotation.map(|a| a.visualized).unwrap_or(false),
                simulated: annotation.map(|a| a.simulated).unwrap_or(false),
                notes: annotation.and_then(|a| a.notes).or(if has_catch_all {
                    Some("via catch-all")
                } else {
                    None
                }),
            });
        }

        // 2. Add manual fields that might NOT be in the snapshot (rare case, or if snapshot is outdated)
        // This ensures if we manually define something we expect, it shows up even if not found in current files.
        for (name, annotation) in &manual_annotations {
            if !fields.iter().any(|f| f.name == *name) {
                fields.push(FieldCoverage {
                    name,
                    parsed: annotation.parsed,
                    visualized: annotation.visualized,
                    simulated: annotation.simulated,
                    notes: annotation.notes,
                });
            }
        }

        // Sort: Parsed/Visualized first, then by frequency (implicit in discovery order), then name
        fields.sort_by(|a, b| {
            let a_score = (if a.parsed { 2 } else { 0 }) + (if a.visualized { 1 } else { 0 });
            let b_score = (if b.parsed { 2 } else { 0 }) + (if b.visualized { 1 } else { 0 });
            b_score.cmp(&a_score).then(a.name.cmp(b.name))
        });

        registry.insert(cat, fields);
    }

    registry
}

struct ManualAnnotation {
    parsed: bool,
    visualized: bool,
    simulated: bool,
    notes: Option<&'static str>,
}

fn get_manual_annotations(category: DataCategory) -> HashMap<&'static str, ManualAnnotation> {
    let mut map = HashMap::new();

    // Helper macro to reduce boilerplate
    // Args: (name, parsed, visualized) or (name, parsed, visualized, notes)
    // simulated defaults to false
    macro_rules! field {
        ($name:expr, $parsed:expr, $visualized:expr, $notes:expr) => {
            map.insert(
                $name,
                ManualAnnotation {
                    parsed: $parsed,
                    visualized: $visualized,
                    simulated: false,
                    notes: $notes,
                },
            );
        };
        ($name:expr, $parsed:expr, $visualized:expr) => {
            map.insert(
                $name,
                ManualAnnotation {
                    parsed: $parsed,
                    visualized: $visualized,
                    simulated: false,
                    notes: None,
                },
            );
        };
    }

    match category {
        DataCategory::Advisortypes => {
            // Auto-load from Struct
            for f in crate::advisortypes::AdvisorType::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
        }
        DataCategory::Countries => {
            field!("color", true, true, Some("Essential for political map"));
            field!(
                "graphical_culture",
                false,
                false,
                Some("For unit models and city graphics")
            );
            field!("<date>", false, false, Some("Time-dependent properties"));
        }
        DataCategory::HistoryProvinces => {
            // Auto-load from Struct
            for f in crate::history::ProvinceHistory::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
            // Manual Additions (non-struct fields)
            field!(
                "<date>",
                false,
                false,
                Some("Time-dependent properties (not yet parsed)")
            );
        }
        DataCategory::Tradegoods => {
            // Auto-load from Struct
            for f in crate::Tradegood::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
        }
        DataCategory::Religions => {
            // Auto-load from Struct
            for f in crate::religions::Religion::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
        }
        DataCategory::Cultures => {
            // Auto-load from Struct
            for f in crate::cultures::Culture::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
        }
        DataCategory::Technologies => {
            // Auto-load from Struct
            for f in crate::technologies::Technology::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
        }
        DataCategory::TimedModifiers => {
            // Auto-load from Struct
            for f in crate::timed_modifiers::TimedModifier::fields() {
                map.insert(
                    f.name,
                    ManualAnnotation {
                        parsed: true,
                        visualized: f.visualized,
                        simulated: f.simulated,
                        notes: None,
                    },
                );
            }
        }
        _ => {}
    }

    map
}

use eu4txt::{DefaultEU4Txt, EU4Txt};
use rayon::prelude::*;
use walkdir::WalkDir;

/// Main entry point: scan EU4 directory and produce coverage report
pub fn analyze_coverage(eu4_path: &Path, discover: bool) -> Result<CoverageReport, std::io::Error> {
    let mut categories = Vec::new();
    let registry = get_gold_standard_registry();
    let now = std::time::SystemTime::now();
    let timestamp = humantime::format_rfc3339(now).to_string();

    // Iterate over all discovered categories
    for &cat in ALL_CATEGORIES {
        let fields = registry.get(&cat).cloned().unwrap_or_default();
        let our_fields = fields.iter().filter(|f| f.parsed).count();
        let visualized_fields = fields.iter().filter(|f| f.visualized).count();
        let simulated_fields = fields.iter().filter(|f| f.simulated).count();
        let total_fields = fields.len();

        let dir_path = eu4_path.join(cat.path_suffix());
        let game_files = count_txt_files(&dir_path);
        let parsed_files = count_parsable_files(&dir_path);

        let discovered_fields = if discover {
            Some(crate::discovery::discover_schema_at_path(
                eu4_path,
                cat.path_suffix(),
                cat.is_nested(),
            )?)
        } else {
            None
        };

        categories.push(CategoryCoverage {
            category: cat,
            game_files,
            parsed_files,
            total_fields,
            our_fields,
            visualized_fields,
            simulated_fields,
            details: fields,
            discovered_fields,
        });
    }

    Ok(CoverageReport {
        categories,
        timestamp,
    })
}

fn count_txt_files(path: &Path) -> usize {
    if !path.exists() {
        return 0;
    }

    WalkDir::new(path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "txt"))
        .count()
}

fn count_parsable_files(path: &Path) -> usize {
    if !path.exists() {
        return 0;
    }

    let files: Vec<_> = WalkDir::new(path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "txt"))
        .collect();

    files
        .par_iter()
        .filter(|entry| {
            let path = entry.path();
            // Try to open and parse
            if let Ok(tokens) = DefaultEU4Txt::open_txt(path.to_str().unwrap_or_default()) {
                if tokens.is_empty() {
                    true // Empty files are considered "parsable" (no errors)
                } else {
                    DefaultEU4Txt::parse(tokens).is_ok()
                }
            } else {
                false
            }
        })
        .count()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_analyze_coverage_mock() {
        let dir = tempdir().unwrap();
        let common = dir.path().join("common");
        let countries_dir = common.join("countries");
        let history_dir = dir.path().join("history/provinces");

        fs::create_dir_all(&countries_dir).unwrap();
        fs::create_dir_all(&history_dir).unwrap();

        // Create 2 country files
        fs::write(countries_dir.join("Sweden.txt"), "color = { 1 1 1 }").unwrap();
        // Empty file parses OK (it's just empty AST)
        fs::write(countries_dir.join("Denmark.txt"), "").unwrap();

        // Create 1 valid history file and 1 invalid
        let p1 = history_dir.join("1.txt");
        fs::write(&p1, "owner = SWE").unwrap();

        let p2 = history_dir.join("2.txt");
        // This fails tokenization or parsing (Missing RHS)
        fs::write(&p2, "key =").unwrap();

        let report = analyze_coverage(dir.path(), false).unwrap();

        // Find Countries category
        let country_cat = report
            .categories
            .iter()
            .find(|c| c.category == DataCategory::Countries)
            .unwrap();
        assert_eq!(country_cat.game_files, 2);
        assert_eq!(country_cat.parsed_files, 2); // Both valid (empty is valid)

        // Find HistoryProvinces category
        let hist_cat = report
            .categories
            .iter()
            .find(|c| c.category == DataCategory::HistoryProvinces)
            .unwrap();
        assert_eq!(hist_cat.game_files, 2);
        assert_eq!(hist_cat.parsed_files, 1);
    }
}
